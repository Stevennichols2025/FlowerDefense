<!DOCTYPE html>
<html>


<head>
    <title>Flower Defense</title>
    <link rel="stylesheet" href="styles/flower_defense_stye.css">
</head> 


<body>

    <canvas id="canvas" style="z-index: -2; position: absolute;"></canvas>

    <!-- DIV Borders -->
    <div id="border-top" class="game-border"></div>
    <div id="border-left" class="game-border"></div>
    <div id="border-right" class="game-border"></div>
    <div id="border-bottom-left" class="game-border"></div>
    <div id="border-bottom-right" class="game-border">
        <!-- Changed div to button -->
        <button id="beehiveDefenseIcon" type="button"></button> 
    </div>
    <!-- End DIV Borders -->

    <div id="startGameContainer">
        <div id="startGameText">FLOWER DEFENSE</div>
        <button id="startGameButton">Start Game</button>
        <div id="decorativeFlowerRow"></div>
    </div>

    <div id="score" class="score">0</div>
    <div id="player">&#x1F33B;</div>
    <div id="Alien">&#x1f6f8;</div>
    <div id="alienHealthContainer">
        <div id="alienHealthBar"></div>
    </div>
    <div id="levelMessageContainer"></div>
    <button id="pauseButton">⏸️</button>

    
    <!-- Add game over container -->
    <div id="gameOverContainer">
        <div id="gameOverText">GAME OVER</div>
        <button id="playAgainButton">Play Again</button>
    </div>

    <script src="scripts/particle.js"></script>
    <script>
        // Global variables for responsive sizing
        let WINDOW_WIDTH, WINDOW_HEIGHT, BORDER_MARGIN, GAME_WIDTH, GAME_HEIGHT;
        let PLAYER_SIZE, BALL_SIZE, ALIEN_SIZE;
        
        // Define Border Width Constants Globally and Early
        const BORDER_WIDTH = 60; // Reduced thickness
        const BOTTOM_BORDER_WIDTH = 120; // Reduced thickness
        const BORDER_OFFSET = BORDER_WIDTH / 2; 
        const BOTTOM_BORDER_OFFSET = BOTTOM_BORDER_WIDTH / 2;

        // Global variables for Game Area Boundaries (derived from DIVs)
        let gameAreaTop, gameAreaLeft, gameAreaRight, gameAreaBottom;
        let gapStartX, gapEndX; // Coordinates for the gap edges

        cTEST_MODE = false 
        BALL_SPEED_DIVISOR = 1500

        let gameLevel = 1; 
        let gameIntervals;
        // Bee-related variables and constants
       
        let beehiveReady = true; // Is the defense ready to use?
        let lastBeehiveTime = 0; // Timestamp of last use
        const BEEHIVE_COOLDOWN = 15000; // 15 seconds cooldown
        let beehiveIconElement = null; // Reference to the icon DOM element

        // This function will be called again if the window is resized 
        function setCharacterSizes() {
            // Calculate core dimensions
            WINDOW_WIDTH = window.innerWidth;
            WINDOW_HEIGHT = window.innerHeight;
            BORDER_MARGIN = Math.min(WINDOW_WIDTH, WINDOW_HEIGHT) * 0.02;
            GAME_WIDTH = WINDOW_WIDTH - (BORDER_MARGIN * 2);
            GAME_HEIGHT = WINDOW_HEIGHT - (BORDER_MARGIN * 2);
            // Keep player/ball/alien sizes
            PLAYER_SIZE = Math.min(WINDOW_WIDTH, WINDOW_HEIGHT) * .1;
            BALL_SIZE = Math.min(WINDOW_WIDTH, WINDOW_HEIGHT) * .07;
            ALIEN_SIZE = Math.min(WINDOW_WIDTH, WINDOW_HEIGHT) * 0.15;

            // --- Style the Border DIVs --- 
            const topBorder = document.getElementById('border-top');
            const leftBorder = document.getElementById('border-left');
            const rightBorder = document.getElementById('border-right');
            const bottomLeftBorder = document.getElementById('border-bottom-left');
            const bottomRightBorder = document.getElementById('border-bottom-right');

            const centerGapWidth = 280; // Increased gap width for another flower
            const gapStartCalc = (WINDOW_WIDTH / 2) - (centerGapWidth / 2);
            const gapEndCalc = (WINDOW_WIDTH / 2) + (centerGapWidth / 2);

            if (topBorder) {
                topBorder.style.top = `${BORDER_MARGIN}px`; 
                topBorder.style.left = `${BORDER_MARGIN}px`; 
                topBorder.style.width = `${GAME_WIDTH}px`;
                topBorder.style.height = `${BORDER_WIDTH}px`; 
            }
            if (leftBorder) {
                leftBorder.style.top = `${BORDER_MARGIN}px`; 
                leftBorder.style.left = `${BORDER_MARGIN}px`; 
                leftBorder.style.width = `${BORDER_WIDTH}px`; 
                leftBorder.style.height = `${GAME_HEIGHT}px`; // Correct height based on game area
            }
            if (rightBorder) {
                rightBorder.style.top = `${BORDER_MARGIN}px`; 
                rightBorder.style.right = `${BORDER_MARGIN}px`; 
                rightBorder.style.width = `${BORDER_WIDTH}px`; 
                rightBorder.style.height = `${GAME_HEIGHT}px`; 
            }
            if (bottomLeftBorder) {
                bottomLeftBorder.style.bottom = `${BORDER_MARGIN}px`; 
                bottomLeftBorder.style.left = `${BORDER_MARGIN}px`; 
                bottomLeftBorder.style.width = `${gapStartCalc - BORDER_MARGIN}px`; // Updated width to wider gap
                bottomLeftBorder.style.height = `${BOTTOM_BORDER_WIDTH}px`; // Use new 160px
            }
            if (bottomRightBorder) {
                bottomRightBorder.style.bottom = `${BORDER_MARGIN}px`; 
                bottomRightBorder.style.right = `${BORDER_MARGIN}px`; 
                bottomRightBorder.style.width = `${WINDOW_WIDTH - gapEndCalc - BORDER_MARGIN}px`; // Updated width from wider gap
                bottomRightBorder.style.height = `${BOTTOM_BORDER_WIDTH}px`; // Use new 160px
            }
            // -----------------------------
            
            // --- Read DIV Boundaries into Global Variables ---
            if (topBorder && leftBorder && rightBorder && bottomLeftBorder && bottomRightBorder) {
                // Use getBoundingClientRect for viewport-relative coordinates
                const topRect = topBorder.getBoundingClientRect();
                const leftRect = leftBorder.getBoundingClientRect();
                const rightRect = rightBorder.getBoundingClientRect();
                const blRect = bottomLeftBorder.getBoundingClientRect();
                const brRect = bottomRightBorder.getBoundingClientRect();

                // Calculate inner game area boundaries
                gameAreaTop = topRect.bottom; 
                gameAreaLeft = leftRect.right;
                gameAreaRight = rightRect.left;
                gameAreaBottom = blRect.top; // Use top edge of bottom border
                gapStartX = blRect.right; // Right edge of bottom-left defines gap start
                gapEndX = brRect.left;   // Left edge of bottom-right defines gap end
                
                console.log("Game Area Boundaries Updated:", { 
                    top: gameAreaTop, 
                    left: gameAreaLeft, 
                    right: gameAreaRight, 
                    bottom: gameAreaBottom, 
                    gapStart: gapStartX, 
                    gapEnd: gapEndX 
                });
            } else {
                console.error("Could not find all border DIV elements to calculate boundaries.");
            }
            // --------------------------------------------------------
        }

        // Call setCharacterSizes immediately to initialize values
        setCharacterSizes();

        // Hide game elements initially
        document.getElementById('score').style.display = 'none';
        document.getElementById('player').style.display = 'none';
        document.getElementById('Alien').style.display = 'none';
        document.getElementById('pauseButton').style.display = 'none';
        document.getElementById('alienHealthContainer').style.display = 'none';

       

        // Initialize game function - Make it async to use await
        async function initializeGame() { 
            // Clear any existing intervals first
            if (gameIntervals) {
                for (let interval in gameIntervals) {
                    clearInterval(gameIntervals[interval]);
                }
            }
            console.log("intervals Cleared")
           
            // Responsive sizing constants (initial call)
            // setCharacterSizes(); 
           
            // Show game elements early 
            document.getElementById('score').style.display = 'block';
            document.getElementById('player').style.display = 'block';
            document.getElementById('pauseButton').style.display = 'block';
            document.getElementById('alienHealthContainer').style.display = 'block';
            
            // Hide start screen
            document.getElementById('startGameContainer').style.display = 'none';

            // Start background music
            startBackgroundMusic();

            // Initialize game state
            isGamePaused = false;

            // Reset player position (using potentially inaccurate initial sizes - negligible effect)
            playerX = window.innerWidth / 2; 
            // Initial bottom guess (will be corrected after fonts load)
            let initialPlayerBottom = window.innerHeight * 0.04; // Simple guess
            player.style.left = `${playerX}px`;
            player.style.bottom = `${initialPlayerBottom}px`;

            // Add flowers if level 1
            if (gameLevel === 1) {
                addFlowers();
            }
            
            // --- Wait for fonts to load before final sizing and drawing ---
            try {
                await document.fonts.ready; 
                console.log('Fonts loaded, proceeding with final layout.');
            } catch (error) {
                console.error('Font loading error or timeout:', error);
            }
            // -------------------------------------------------------------

            // Calculate final sizes ONCE *after* fonts are ready
            setCharacterSizes(); 

            // Update player position AGAIN with accurate sizes
            playerX = WINDOW_WIDTH / 2; // Recenter based on final width
            player.style.left = `${playerX}px`; 
            // Set bottom edge of player to align exactly with gameAreaBottom
            player.style.bottom = `${WINDOW_HEIGHT - gameAreaBottom}px`; 
            
            // Draw the borders using final dimensions
            draw();
            
            // Create alien and ball using final dimensions
            createAlien();  
            document.getElementById('Alien').style.display = 'block';  
            createBall();
            
            // Start game intervals with fresh set
            gameIntervals = {
                createBall: setInterval(() => {
                    // As levels progress, increase chance of creating armored balls
                    const armoredChance = Math.min(0.3, 0.05 + (gameLevel - 1) * 0.05); // Up to 30% max
                    
                    if (Math.random() < armoredChance && gameLevel > 1) {
                        createBall("random", "armored");
                    } else {
                        createBall("random", "standard");
                    }
                }, 2000),
                moveBalls: setInterval(moveBalls, 20),
                moveAlien: setInterval(moveAlien, 20),
                updatePlayer: setInterval(updatePlayer, 10),
                moveLasers: setInterval(moveLasers, 15),
                createBonus: setInterval(createBonus, 5000), // Create a bonus every 5 seconds
                moveBonuses: setInterval(moveBonuses, 20),   // Move bonuses at same rate as balls
                moveBees: setInterval(moveBees, 25) // Move bees 
            };
            console.log("gameIntervals ReCreated")
            console.log(balls.length)

            levelMessageContainer = document.getElementById('levelMessageContainer');
            beehiveIconElement = document.getElementById('beehiveDefenseIcon'); // Cache icon
            scoreElement = document.getElementById('score'); 
            
            // Initialize the beehive icon directly here
            if (beehiveIconElement) {
                console.log("Found beehiveIconElement during initialization.", beehiveIconElement);
                beehiveIconElement.innerHTML = '&#x1F41D;'; // Bee emoji
                // REMOVED: beehiveIconElement.addEventListener('click', launchBeeSwarm); 
                // console.log("Listener ADDED to beehiveIconElement."); // Log no longer accurate
            } else {
                console.error("FAILED to find beehiveIconElement during initialization.");
            }
            
            // REMOVED call to initializeBeehiveIcon();

            // ... (rest of initialization)
        }

        // Add start button listener
        document.getElementById('startGameButton').addEventListener('click', initializeGame);

        // Modify restart game function to use initialization
        function restartGame(levelUp = false) {
            // Hide game over screen if it's showing
            document.getElementById('gameOverContainer').style.display = 'none';
            
            // Always reset gameLevel to 1 when restarting
            gameLevel = 1;
            
            // Always reset score when restarting (regardless of levelUp)
            score = 0;
            document.getElementById('score').innerHTML = '0';
            document.getElementById('score').style.display = 'block';

            // Clear existing balls
            while(balls.length > 0) {
                const ball = balls.pop();
                ball.destroy();
            }

            // Clear existing lasers
            while(lasers.length > 0) {
                const laser = lasers.pop();
                laser.destroy();
            }

            // Clear existing bonuses
            while(bonuses.length > 0) { 
                const bonus = bonuses.pop();
                bonus.destroy();
            }

            // Clear any existing bees & reset beehive
            while(bees.length > 0) {
                const bee = bees.pop();
                bee.destroy();
            }
            beehiveReady = true; // Reset readiness
            if (beehiveIconElement) {
                beehiveIconElement.classList.remove('cooldown'); // Remove cooldown style
                beehiveIconElement.innerHTML = '&#x1F41D;'; // Ensure bee icon
            }

            // Reset and recreate alien
            const oldAlien = aliens.pop();
            if (oldAlien && oldAlien.element) {
                oldAlien.element.remove();
            }
            
            if (!levelUp) {
                // Clear existing flowers
                const flowers = document.getElementsByClassName('static-flower');
                while(flowers.length > 0) {
                    flowers[0].remove();
                }
                addFlowers();
            }

            // Initialize fresh game
            console.log("Game Restarted with score reset to: " + score);
            initializeGame();
           
        }

       

        // Update element sizes
        document.getElementById('player').style.fontSize = `${PLAYER_SIZE}px`;
        document.getElementById('Alien').style.fontSize = `${ALIEN_SIZE}px`;
        document.getElementById('score').style.fontSize = `${Math.min(WINDOW_WIDTH, WINDOW_HEIGHT) * 0.10}px`;
        document.getElementById('score').style.top = '3px';

        // Initialize canvas
        const canvas = document.querySelector('#canvas');
        // canvas.width = WINDOW_WIDTH; // Initial width setting might be redundant now
        // canvas.height = WINDOW_HEIGHT; // Initial height setting might be redundant now
        
        // REMOVE old const declarations from here
        // const BORDER_WIDTH = 100;
        // const BOTTOM_BORDER_WIDTH = 200;
        // const BORDER_OFFSET = BORDER_WIDTH / 2;
        // const BOTTOM_BORDER_OFFSET = BOTTOM_BORDER_WIDTH / 2;

        // Add game state variable
        let isGamePaused = false;

        // Game configuration constants
        const cMAXBALLS = 10;
        const cPARTICLES = false;
        const LASER_HITBOX_WIDTH = 25; // Width of laser collision detection in pixels
        let score = 0; // Game score - global variable

        const LASER_SOUND = new Audio('sounds/laser_fire.mp3');
        const SPACESHIP_HIT_SOUND = new Audio('sounds/spaceship_hit.mp3');
        const FLOWER_HIT_SOUND = new Audio('sounds/flower_hit.mp3');
        const BACKGROUND_MUSIC = new Audio('sounds/space-ranger-moire-main-version-03-04-10814.mp3');
        const ARMORED_HIT_SOUND = new Audio('sounds/armored_hit.mp3');
        const ARMORED_DEFEAT_SOUND =  new Audio('sounds/armored_defeat.mp3');


         // Set volume levels
        BACKGROUND_MUSIC.volume = 0.5;  // Background music at 30% volume
        LASER_SOUND.volume = 0.7;       // Sound effects at 70% volume
        SPACESHIP_HIT_SOUND.volume = 0.7;
        FLOWER_HIT_SOUND.volume = 0.7;
        
        BACKGROUND_MUSIC.loop = true;  // Make the music loop continuously

        // Function to handle background music
        function startBackgroundMusic() {
            BACKGROUND_MUSIC.currentTime = 0;  // Reset to start
            BACKGROUND_MUSIC.play();
        }
       
        function addFlowers() {
            const flowerHeightEstimate = BALL_SIZE * 0.8; // Estimate flower height
            const verticalGap = 10; // Gap between rows
            const bottomRowBottomPosition = BORDER_MARGIN + verticalGap; // Position first row near bottom border
            const secondRowBottomPosition = bottomRowBottomPosition + flowerHeightEstimate + verticalGap; // Position second row above first

            // --- First (Lowest) Row of Flowers (5 total) ---
            const bottomPositions = [-110, -62, -14, 35, 88]; // Horizontal offsets from center
            var bottomFlowerNum = 0;

            bottomPositions.forEach(pos => {
                bottomFlowerNum += 1; 
                const flower = document.createElement('div');
                flower.className = 'static-flower bottom-flower'; // Keep static-flower class
                flower.style.left = `calc(50% + ${pos}px)`;
                flower.style.bottom = `${bottomRowBottomPosition}px`; // Explicitly set bottom position
                flower.style.setProperty('--pulse-delay', `${bottomFlowerNum * 0.3}s`);
                
                if (bottomFlowerNum % 2 === 0) {
                   flower.innerHTML = '&#x1F33A;'; // Hibiscus
                } else {
                    flower.innerHTML = '&#x1F337;'; // Tulip
                }
               
                document.body.appendChild(flower);
            });

            // --- Second Row of Flowers (Above First Row, 5 total) ---
            const secondRowCount = 5;
            const gapWidth = gapEndX - gapStartX;
            const horizontalSpacing = gapWidth / (secondRowCount + 1); // Divide gap width for spacing
            var secondRowFlowerNum = 0;

            for (let i = 1; i <= secondRowCount; i++) {
                secondRowFlowerNum += 1;
                const flower = document.createElement('div');
                flower.className = 'static-flower second-row-flower'; // Keep static-flower, add specific class
                const flowerX = gapStartX + (horizontalSpacing * i); // Position relative to gap start
                flower.style.left = `${flowerX}px`;
                flower.style.bottom = `${secondRowBottomPosition}px`; // Position above the first row
                flower.style.setProperty('--pulse-delay', `${(bottomFlowerNum + secondRowFlowerNum) * 0.2}s`); // Vary delay

                if (secondRowFlowerNum % 2 === 0) {
                   flower.innerHTML = '&#x1F33B;'; // Sunflower
                } else {
                    flower.innerHTML = '&#x1F33C;'; // Blossom
                }

                document.body.appendChild(flower);
            }
        }
        function draw() {
            const canvas = document.querySelector('#canvas');
            if (!canvas.getContext) {
                return;
            }
            const ctx = canvas.getContext('2d');

            // --- Keep Canvas Clearing (for background/particles) ---
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // --- End of Clearing ---

            // --- REMOVED ALL ctx.stroke() and OVERLAY CREATION ---
            // The border visuals are now handled by HTML/CSS
            // --- END OF REMOVALS ---
        }

        // ****** Laser Class *****************************
        class Laser {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.speed = 25;  // Define a consistent speed
                this.width = 5;   // Visual width of the laser beam
            }

            move() {
                this.y -= this.speed;  // Move up by speed amount
                this.element.style.left = `${this.x}px`;
                this.element.style.top = `${this.y}px`;
            }

            create() {
                const laserElement = document.createElement('div');
                laserElement.className = 'laser';
                laserElement.style.width = `${this.width}px`;
                laserElement.style.height = '25px';
                laserElement.style.backgroundColor = '#0ff'; // Cyan color
                laserElement.style.boxShadow = '0 0 5px #0ff, 0 0 10px #0ff'; // Glow effect
                laserElement.style.left = `${this.x - (this.width/2)}px`; // Center the laser on x
                laserElement.style.top = `${this.y}px`;
                document.body.appendChild(laserElement);
                this.element = laserElement;
            }

            destroy() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
            }
        }
        // ******** end of laser class *********

        class Alien {
            constructor(size, color, x, y, speed) {
                this.size = size;
                this.color = color;
                this.x = x;
                this.y = y;
                this.initialY = y; // Store initial Y
                this.baseSpeed = speed; // Store base horizontal speed
                this.speed = speed; // Current horizontal speed
                this.isHit = false;
                this.isDefeated = false; 
                cTEST_MODE ? this.health = 20 : this.health = 100; 
                
                this.isBerserk = false; // <<< ADDED: Berserk flag
                this.berserkTargetY = 0; // <<< ADDED: Target Y for berserk mode
                this.verticalSpeed = 3; // <<< ADDED: Speed for moving down
            }

            create() {
                let alienElement = document.getElementById("Alien");
                if (!alienElement) {
                    // Only create new element if it doesn't exist
                    alienElement = document.createElement('div');
                    alienElement.id = 'Alien';
                    alienElement.innerHTML = '&#x1f6f8;';
                    document.body.appendChild(alienElement);
                }
                alienElement.className = 'alien';
                alienElement.style.width = this.size + 'px';
                alienElement.style.height = this.size + 'px';
                alienElement.style.fontSize = `${ALIEN_SIZE}px`;
                this.element = alienElement;

                // Calculate berserk target Y position (needs gameArea boundaries)
                this.berserkTargetY = gameAreaTop + (gameAreaBottom - gameAreaTop) / 2 - (this.size / 2);
                console.log(`Alien created. InitialY=${this.initialY.toFixed(2)}, BerserkTargetY=${this.berserkTargetY.toFixed(2)}`);

                // Reset position and health bar
                this.element.style.top = this.y + 'px';
                document.getElementById('alienHealthBar').style.width = '100%';
            }

            takeDamage() {
                this.health = Math.max(0, this.health - 4);  
                document.getElementById('alienHealthBar').style.width = `${this.health}%`;
                
                // --- Berserk Trigger --- 
                if (this.health <= 25 && !this.isBerserk) {
                    console.log("Alien entering BERSERK mode!");
                    this.isBerserk = true;
                    // Add visual indicator
                    if (this.element) {
                        this.element.classList.add('berserk');
                    }
                }
                // ---------------------

                if (this.health <= 0) {
                    this.defeat();
                }
            }

            defeat() {
                // Set defeated flag
                this.isDefeated = true;
                
                // Create big explosion effect
                const explosion = document.createElement('div');
                explosion.className = 'big-explosion';
                explosion.style.left = (this.x + this.size/2 - 100) + 'px';
                explosion.style.top = (this.y + this.size/2 - 100) + 'px';
                document.body.appendChild(explosion);

                // Add defeat animation to alien
                this.element.classList.add('alien-defeat');

                // Play explosion sound
                SPACESHIP_HIT_SOUND.currentTime = 0;
                SPACESHIP_HIT_SOUND.play();

                // Show level complete message
                showLevelComplete();

                // Clear any existing balls
                while(balls.length > 0) {
                    const ball = balls.pop();
                    ball.destroy();
                }

                // Clear any existing bonuses
                while(bonuses.length > 0) { 
                    const bonus = bonuses.pop();
                    bonus.destroy();
                }

                BACKGROUND_MUSIC.pause();  // Stop the music

                // Remove explosion effect
                explosion.remove();

                // Make sure to remove berserk visual if active
                if (this.element) {
                    this.element.classList.remove('berserk');
                    this.element.classList.add('alien-defeat');
                }
            }

            move() {
                // --- Calculate Horizontal Speed --- 
                const levelMultiplier = 1 + (gameLevel - 1) * 0.12; // Existing level scaling
                const berserkMultiplier = this.isBerserk ? 1.8 : 1; // Speed boost for berserk
                const currentHorizontalSpeed = this.baseSpeed * levelMultiplier * berserkMultiplier;
                let horizontalDirection = Math.sign(this.speed); // Get current direction (-1 or 1)
                this.speed = currentHorizontalSpeed * horizontalDirection; // Apply speed with direction
                // ----------------------------------

                // --- Vertical Movement (Berserk Transition) ---
                if (this.isBerserk && this.y < this.berserkTargetY) {
                    this.y += this.verticalSpeed;
                    // Clamp Y to targetY if overshot
                    if (this.y > this.berserkTargetY) {
                        this.y = this.berserkTargetY;
                    }
                } // Add else if later if it needs to move back up?
                // ---------------------------------------------

                // --- Horizontal Movement & Wall Collision ---
                this.x += this.speed; 
                if (this.x < gameAreaLeft || this.x + this.size > gameAreaRight) {
                    this.speed *= -1; // Reverse direction
                    // Adjust position slightly
                    if (this.x < gameAreaLeft) {
                        this.x = gameAreaLeft;
                    }
                    if (this.x + this.size > gameAreaRight) {
                        this.x = gameAreaRight - this.size;
                    }
                }
                // -----------------------------------------

                // Update element position (Both Left and Top)
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px'; 
            }

            createExplosion() {
                const numParticles = 60;
                const explosionContainer = document.createElement('div');
                explosionContainer.style.position = 'absolute';
                explosionContainer.style.left = (this.x + this.size/2) + 'px';
                explosionContainer.style.top = (this.y + this.size/2) + 'px';
                explosionContainer.style.zIndex = '1000';
                
                for (let i = 0; i < numParticles; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'explosion-particle';
                    
                    // Calculate random direction for each particle
                    const angle = (i / numParticles) * 360 + Math.random() * 30;
                    const distance = 50 + Math.random() * 30;
                    const tx = Math.cos(angle * Math.PI / 180) * distance;
                    const ty = Math.sin(angle * Math.PI / 180) * distance;
                    
                    particle.style.setProperty('--tx', `${tx}px`);
                    particle.style.setProperty('--ty', `${ty}px`);
                    
                    explosionContainer.appendChild(particle);
                }
                
                document.body.appendChild(explosionContainer);
                
                // Remove explosion container after animation
                setTimeout(() => {
                    if (explosionContainer.parentNode) {
                        explosionContainer.parentNode.removeChild(explosionContainer);
                    }
                }, 600);
            }

            flash() {
                if (!this.isHit) {
                    this.isHit = true;
                    
                    // Create explosion effect
                    this.createExplosion();

                    // Add wobble animation
                    this.element.classList.add('wobble');
                    
                    // Remove wobble after animation
                    setTimeout(() => {
                        this.element.classList.remove('wobble');
                        this.isHit = false;
                    }, 300);
                }
            }

            isColliding(x, y, size) {
                const alienCenterX = this.x + this.size/2;
                const alienCenterY = this.y + this.size/2;
                const targetCenterX = x + size/2;
                const targetCenterY = y + size/2;

                const dx = alienCenterX - targetCenterX;
                const dy = alienCenterY - targetCenterY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                return distance < (this.size/2 + size/2);
            }
        }

        class Ball {
            constructor(size, color, x, y, speed, angle, type = 'standard') {
                this.size = BALL_SIZE;
                this.color = color;
                this.x = x;
                this.y = y;
                this.type = type; // 'standard' or 'armored'
                this.hitPoints = this.type === 'standard' ? 1 : 4;
                const levelMultiplier = 1 + (gameLevel - 1) * 0.10;
                this.speed = speed * (GAME_WIDTH / 1500) * levelMultiplier;
                this.angle = angle;
                this.lastPlayerHitTime = 0;
                this.playerImmunityEndTime = 0;
                this.isTargetedByBee = false; // <<< ADDED: Flag for bee targeting
            }
            
            create() {
                const ballElement = document.createElement('div');
                ballElement.className = 'ball';
                ballElement.style.width = this.size + 'px';
                ballElement.style.height = this.size + 'px';
                
                // Choose emoji based on type
                const emojiMap = {
                    'standard': '&#x1F47D;', // Regular alien
                    'armored': '&#x1F47E;'   // Alien monster/space invader
                };
                
                ballElement.innerHTML = emojiMap[this.type] || emojiMap['standard'];
                ballElement.style.fontSize = `${this.size}px`;
                ballElement.style.color = this.color;
                
                // Add a subtle visual indicator of armored status
                if (this.type === 'armored') {
                    ballElement.style.textShadow = '0 0 10px #ff0, 0 0 15px #ff0'; // Yellow glow
                }
                
                document.body.appendChild(ballElement);
                this.element = ballElement;
            }
            
            // New method to handle taking damage
            takeDamage() {
                this.hitPoints--;
                // Visual feedback
                this.flash();
                return this.hitPoints <= 0; // Return true if destroyed
            }
            
            // Flash effect when hit
            flash() {
                if (this.element) {
                    // Store original color
                    const originalColor = this.element.style.color;
                    // Flash white
                    this.element.style.color = '#fff';
                   
                    // Return to original color
                    setTimeout(() => {
                        if (this.element) {
                            this.element.style.color = originalColor;
                            
                            // Update visual indicator based on remaining health (for armored balls)
                            if (this.type === 'armored') {
                                const opacity = this.hitPoints / 3; // Fade based on remaining health
                                this.element.style.textShadow = `0 0 10px rgba(255,255,0,${opacity}), 0 0 15px rgba(255,255,0,${opacity})`;
                            }
                        }
                    }, 100);
                }
            }

            destroy() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
            }

            move() {
                const radianAngle = (this.angle * Math.PI) / 180;
                const yVelocity = Math.sin(radianAngle) * this.speed;
                const xSpeed = Math.cos(radianAngle) * this.speed;
                const ySpeed = Math.sin(radianAngle) * this.speed;

                // 1. Calculate potential next position
                let potentialX = this.x + xSpeed;
                let potentialY = this.y + ySpeed;

                // Calculate potential visual edges 
                const visualLeft = potentialX - this.size / 2;
                const visualRight = potentialX + this.size / 2;
                const visualTop = potentialY - this.size / 2;
                const visualBottom = potentialY + this.size / 2;

                // 2. Perform Wall Collision Checks & Corrections
                if (visualLeft < gameAreaLeft) {
                    this.angle = 180 - this.angle;
                    potentialX = gameAreaLeft + this.size / 2; 
                } else if (visualRight > gameAreaRight) {
                    this.angle = 180 - this.angle;
                    potentialX = gameAreaRight - this.size / 2; 
                }
                if (visualTop < gameAreaTop && yVelocity < 0) { 
                    this.angle = 360 - this.angle;
                    potentialY = gameAreaTop + this.size / 2; 
                }

                // 3. Perform Player Collision Check & Corrections (if immunity allows)
                const now = Date.now(); 
                const playerImmunityDuration = 300; 
                if (now > this.playerImmunityEndTime) {
                    // Calculate player hitbox boundaries (using reduced size)
                    const playerBottomYVal = parseFloat(player.style.bottom || '0'); 
                    const playerTopYVal = WINDOW_HEIGHT - playerBottomYVal - PLAYER_SIZE;
                    const playerCollisionWidthVal = PLAYER_SIZE * 0.4; 
                    const playerCollisionHeightVal = PLAYER_SIZE * 0.8; 
                    const playerVisualOffsetX = playerCollisionWidthVal / 2;
                    const playerLeftXVal = playerX - playerVisualOffsetX;
                    const playerRightXVal = playerX + playerVisualOffsetX;
                    const playerCollisionTopYVal = playerTopYVal + (PLAYER_SIZE - playerCollisionHeightVal) / 2; 
                    const playerCollisionBottomYVal = playerCollisionTopYVal + playerCollisionHeightVal;

                    // Check for overlap
                    if (potentialX + this.size / 2 > playerLeftXVal && 
                        potentialX - this.size / 2 < playerRightXVal &&
                        potentialY + this.size / 2 > playerCollisionTopYVal && 
                        potentialY - this.size / 2 < playerCollisionBottomYVal) 
                    { 
                        this.playerImmunityEndTime = now + playerImmunityDuration; // Set immunity

                        // Apply Penalty/Boost (separate cooldown)
                        const playerHitCooldown = 200; 
                        if (now - this.lastPlayerHitTime > playerHitCooldown) {
                            // ... (penalty, boost, log, warning effect logic) ...
                             if (score > 0) { score--; document.getElementById('score').innerHTML = score.toString(); }
                             this.speed *= 1.2;
                             this.lastPlayerHitTime = now;
                             console.log(`Player hit! Score: ${score}, New Ball Speed: ${this.speed.toFixed(2)}`); 
                             const warningDuration = 400;
                             applyBorderEffect('border-top', 'warning', warningDuration);
                             applyBorderEffect('border-left', 'warning', warningDuration);
                             applyBorderEffect('border-right', 'warning', warningDuration);
                             applyBorderEffect('border-bottom-left', 'warning', warningDuration);
                             applyBorderEffect('border-bottom-right', 'warning', warningDuration);
                        }
                        
                        // Apply Bounce Physics (Modify potentialX/Y and angle)
                        if (potentialX < playerLeftXVal || potentialX > playerRightXVal) { 
                            // SIDE HIT LOGIC (Upper/Lower check based on visual center)
                             const playerVisualCenterYVal = playerTopYVal + PLAYER_SIZE / 2;
                             const separationBufferVal = 8; 
                             if (visualBottom >= playerVisualCenterYVal) { // Lower Half
                                 if (potentialX < playerX) { this.angle = 45 + (Math.random()*10-5); potentialX = playerLeftXVal - this.size/2 - separationBufferVal; }
                                 else { this.angle = 135 + (Math.random()*10-5); potentialX = playerRightXVal + this.size/2 + separationBufferVal; }
                             } else { // Upper Half
                                 this.angle = 180 - this.angle + playerSpeed * 1.5; 
                                 this.angle = (this.angle + 360) % 360;
                                 if (potentialX < playerX) { potentialX = playerLeftXVal - this.size/2 - separationBufferVal; }
                                 else { potentialX = playerRightXVal + this.size/2 + separationBufferVal; }
                             }
                             potentialY -= 1; // Nudge up after side hit
                             const correctedVisualBottom = potentialY + this.size / 2;
                             if (correctedVisualBottom > gameAreaBottom) {
                                 potentialY = gameAreaBottom - this.size / 2 - 1;
                             }
                        } else { 
                            // TOP HIT LOGIC
                            if (ySpeed > 0) { 
                                this.angle = 360 - this.angle;
                                potentialY = playerTopYVal - this.size / 2 -1; // Place slightly above visual top 
                            } 
                            // Ignore if moving up
                        }
                    }
                } 

                // 4. Perform Bottom Collision Checks (using potentially modified potentialX/Y)
                if (potentialY > gameAreaBottom) { // Check ball CENTER against game area bottom
                    const ballCenterXVal = potentialX;

                    // Check if horizontally within the gap
                    if (ballCenterXVal >= gapStartX && ballCenterXVal <= gapEndX) {
                        // Ball is potentially in the flower gap
                        const flowers = document.getElementsByClassName('static-flower');
                        // let hitFlower = false; // Flag not needed due to immediate return
                        for (let flower of flowers) {
                            const flowerRect = flower.getBoundingClientRect();
                            const flowerCenterXVal = flowerRect.left + flowerRect.width / 2;
                            const flowerCenterYVal = flowerRect.top + flowerRect.height / 2;
                            const dxVal = ballCenterXVal - flowerCenterXVal;
                            // Use potentialY for ball's vertical center check
                            const dyVal = potentialY - flowerCenterYVal;
                            const distanceVal = Math.sqrt(dxVal*dxVal + dyVal*dyVal);

                            // Check collision based on ball radius and flower radius (approx)
                            if (distanceVal < (this.size / 2 + flowerRect.width / 2)) {
                                // hitFlower = true; // Mark that a flower was hit
                                createFlowerDeathAnimation(flower);
                                setTimeout(() => {
                                    flower.remove();
                                    if (document.getElementsByClassName('static-flower').length === 0) {
                                        setTimeout(endGame, 1000);
                                    }
                                }, 100);
                                this.destroy();
                                balls.splice(balls.indexOf(this), 1);
                                return; // Destroyed - exit function immediately
                            }
                        }
                        // If loop completes and no flower was hit, ball passes through gap.
                        // Position (potentialX, potentialY) will be updated at the end.

                    } else {
                        // Hit solid bottom border - Bounce logic
                        // Calculate current Y speed again to ensure we bounce only when moving down
                        const currentRadianAngle = (this.angle * Math.PI) / 180;
                        const currentYSpeed = Math.sin(currentRadianAngle) * this.speed;

                        if (currentYSpeed > 0) { // Only bounce if moving down
                            this.angle = 360 - this.angle;
                            // Correct position to be just above the border line
                            potentialY = gameAreaBottom - this.size / 2 - 1; // Place edge slightly above
                        }
                        // If moving up towards the border, let it pass (position updated at end)
                    }
                }

                // 5. Final Position Update (Always happens unless returned early after flower hit)
                this.x = potentialX;
                this.y = potentialY;

                // 6. Update element style 
                if (this.element && this.element.parentNode) {
                     this.element.style.left = this.x + 'px';
                     this.element.style.top = this.y + 'px';
                }
            }
            isColliding(x, y, size) {
                const ballCenterX = this.x + this.size/2;
                const ballCenterY = this.y + this.size/2;
                const targetCenterX = x + size/2;
                const targetCenterY = y + size/2;

                const dx = ballCenterX - targetCenterX;
                const dy = ballCenterY - targetCenterY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                return distance < (this.size/2 + size/2);
            }

            createExplosion() {
                const numParticles = 12;
                const explosionContainer = document.createElement('div');
                explosionContainer.style.position = 'absolute';
                explosionContainer.style.left = (this.x + this.size/2) + 'px';
                explosionContainer.style.top = (this.y + this.size/2) + 'px';
                explosionContainer.style.zIndex = '1000';
                
                for (let i = 0; i < numParticles; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '6px';
                    particle.style.height = '6px';
                    particle.style.backgroundColor = this.color;
                    particle.style.borderRadius = '50%';
                    particle.style.pointerEvents = 'none';
                    
                    // Calculate random direction for each particle
                    const angle = (i / numParticles) * 360 + Math.random() * 30;
                    const distance = 30 + Math.random() * 20;
                    const tx = Math.cos(angle * Math.PI / 180) * distance;
                    const ty = Math.sin(angle * Math.PI / 180) * distance;
                    
                    // Add animation
                    particle.style.animation = 'explode 0.3s ease-out forwards';
                    particle.style.setProperty('--tx', `${tx}px`);
                    particle.style.setProperty('--ty', `${ty}px`);
                    
                    explosionContainer.appendChild(particle);
                }
                
                document.body.appendChild(explosionContainer);
                
                // Remove explosion container after animation
                setTimeout(() => {
                    if (explosionContainer.parentNode) {
                        explosionContainer.parentNode.removeChild(explosionContainer);
                    }
                }, 300);
            }
        }

        function draw() {
            const canvas = document.querySelector('#canvas');
            if (!canvas.getContext) {
                return;
            }
            const ctx = canvas.getContext('2d');

            // --- Keep Canvas Clearing (for background/particles) ---
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // --- End of Clearing ---

            // --- REMOVED ALL ctx.stroke() and OVERLAY CREATION ---
            // The border visuals are now handled by HTML/CSS
            // --- END OF REMOVALS ---
        }

        // ****** Bonus Class (For adding bonus boxes to the screen that the player can hit to collect points*********)
        class Bonus {
            constructor(startYPosition) { // Renamed parameter for clarity
                this.size = BALL_SIZE * 0.7; 
                this.value = 5 * (Math.floor(Math.random() * 6) + 1);
                const baseSpeed = 8 * (GAME_WIDTH / 1500); 
                const levelMultiplier = 1 + (gameLevel - 1) * 0.08; 
                this.speed = baseSpeed * levelMultiplier;

                // --- Sine Wave & Direction --- 
                this.direction = Math.random() < 0.5 ? 1 : -1; // 1 = R->L, -1 = L->R
                this.startY = startYPosition; // Vertical center of the wave
                this.amplitude = Math.random() * 80 + 40; // Random wave height (20 to 60px)
                this.frequency = Math.random() * 0.02 + 0.01; // Random wave tightness (0.01 to 0.03)
                this.time = 0; // Time variable for sine wave calculation
                
                // Set initial X based on direction
                if (this.direction === 1) {
                    this.x = gameAreaRight + this.size; // Start off-screen right
                } else {
                    this.x = gameAreaLeft - this.size; // Start off-screen left
                }
                this.y = this.startY; // Initial Y position
                // --- End Sine Wave & Direction ---

                this.element = null;
            }

            create() {
                const bonusElement = document.createElement('div');
                bonusElement.className = 'bonus'; 
                // --- Dynamic Styles (Set via JS) ---
                bonusElement.style.width = `${this.size}px`;
                bonusElement.style.height = `${this.size}px`;
                bonusElement.style.position = 'absolute'; // Keep position absolute for JS control
                bonusElement.style.left = `${this.x}px`;
                bonusElement.style.top = `${this.y}px`; // Use initial Y
                bonusElement.style.fontSize = `${this.size * 0.5}px`; 
                bonusElement.textContent = this.value; 

                document.body.appendChild(bonusElement);
                this.element = bonusElement;
            }

            move() {
                // Update horizontal position based on direction
                this.x += this.speed * this.direction * -1; // -1 because direction 1 means R->L (negative X movement)
                
                // Update vertical position using sine wave
                this.time += 1;
                this.y = this.startY + this.amplitude * Math.sin(this.frequency * this.time);
                
                // Clamp Y to stay within game area boundaries (optional but good practice)
                this.y = Math.max(gameAreaTop + this.size / 2, 
                                Math.min(this.y, gameAreaBottom - this.size / 2));

                if (this.element) {
                    this.element.style.left = `${this.x}px`;
                    this.element.style.top = `${this.y}px`;
                }

                // Check if off-screen (adjust for both directions)
                const isOffScreenLeft = this.direction === 1 && (this.x + this.size < gameAreaLeft);
                const isOffScreenRight = this.direction === -1 && (this.x > gameAreaRight);

                if (isOffScreenLeft || isOffScreenRight) {
                    this.destroy();
                    const index = bonuses.indexOf(this);
                    if (index > -1) {
                        bonuses.splice(index, 1);
                    }
                }
            }

            // Method called when hit by a laser
            hit() {
                score += this.value; // Award points
                document.getElementById('score').innerHTML = score.toString();
                // TODO: Play bonus collect sound
                // BONUS_COLLECT_SOUND.currentTime = 0;
                // BONUS_COLLECT_SOUND.play();

                this.createHitEffect(); // Trigger visual effect
                this.destroy(); // Remove element

                // Find and remove from the global bonuses array immediately
                const index = bonuses.indexOf(this);
                if (index > -1) {
                    bonuses.splice(index, 1);
                }
            }

            createHitEffect() {
                // Dramatic particle effect (e.g., purple/gold particles)
                const numParticles = 25;
                const effectContainer = document.createElement('div');
                effectContainer.style.position = 'absolute';
                // Center the effect on the bonus's last position
                effectContainer.style.left = (this.x + this.size / 2) + 'px';
                effectContainer.style.top = (this.y + this.size / 2) + 'px';
                effectContainer.style.zIndex = '1100'; // Above other elements

                for (let i = 0; i < numParticles; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '8px'; // Slightly larger particles
                    particle.style.height = '8px';
                    // Alternate colors
                    particle.style.backgroundColor = i % 2 === 0 ? 'gold' : 'purple';
                    particle.style.borderRadius = '50%';
                    particle.style.boxShadow = `0 0 5px ${particle.style.backgroundColor}`; // Glow
                    particle.style.pointerEvents = 'none';

                    // Similar explosion animation to balls/alien
                    const angle = Math.random() * 360;
                    const distance = 50 + Math.random() * 40;
                    const tx = Math.cos(angle * Math.PI / 180) * distance;
                    const ty = Math.sin(angle * Math.PI / 180) * distance;

                    particle.style.animation = 'explode 0.5s ease-out forwards'; // Longer duration
                    particle.style.setProperty('--tx', `${tx}px`);
                    particle.style.setProperty('--ty', `${ty}px`);

                    effectContainer.appendChild(particle);
                }

                document.body.appendChild(effectContainer);

                // Remove effect container after animation
                setTimeout(() => {
                    if (effectContainer.parentNode) {
                        effectContainer.parentNode.removeChild(effectContainer);
                    }
                }, 500); // Match animation duration
            }


            destroy() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                    this.element = null; // Clear reference
                }
            }
        }
                // ****** Bee Class (For the Beehive Defense) *********
        class Bee {
            constructor(startX, startY) {
                this.size = 24; 
                this.x = startX;
                this.y = startY;
                this.baseSpeed = 4 + Math.random() * 2; 
                this.speed = this.baseSpeed; 
                this.drift = (Math.random() - 0.5) * 1; 
                this.element = null;
                this.targetBall = null; 
                this.state = 'seeking'; 
                
                // <<< ADDED: Idle Target Initialization >>>
                this.setNewIdleTarget(); 
            }

            // <<< ADDED: Helper function to set a new random idle target >>>
            setNewIdleTarget() {
                // Ensure gameArea boundaries are defined before calling this
                const padding = this.size * 2; // Keep away from edges
                this.idleTargetX = gameAreaLeft + padding + Math.random() * (gameAreaRight - gameAreaLeft - 2 * padding);
                // Target upper 2/3rds of the game area for patrolling
                this.idleTargetY = gameAreaTop + padding + Math.random() * ((gameAreaBottom - gameAreaTop) * 0.66 - padding);
                console.log(`Bee ${this.element?.id || 'New'} set new idle target: (${this.idleTargetX.toFixed(2)}, ${this.idleTargetY.toFixed(2)})`);
            }

            create() {
                const beeElement = document.createElement('div');
                beeElement.className = 'bee';
                beeElement.innerHTML = '&#x1F41D;'; // Honeybee emoji
                beeElement.style.left = `${this.x - this.size / 2}px`; // Center horizontally
                beeElement.style.top = `${this.y - this.size / 2}px`; // Center vertically
                beeElement.style.fontSize = `${this.size}px`; // Ensure size matches
                // Other styles like position: absolute are handled by CSS
                console.log(`Bee element created with style: left=${beeElement.style.left}, top=${beeElement.style.top}`); // <<< LOG ELEMENT STYLE
                document.body.appendChild(beeElement);
                this.element = beeElement;
            }

            move() {
                const oldY = this.y;
                const oldX = this.x;
                let moveDescription = "Default"; // Simplified log description

                // --- State-Based Movement --- 
                if (this.state === 'attacking') {
                    // ... (Target validation logic remains the same) ...
                    if (!this.targetBall || this.targetBall.element === null || !balls.includes(this.targetBall)) {
                        // ... (Handle lost target -> seeking) ...
                        console.log(`Bee ${this.element?.id || 'N/A'} lost target, switching to seeking.`);
                        if(this.targetBall) this.targetBall.isTargetedByBee = false; // Clear flag if target existed
                        this.targetBall = null;
                        this.state = 'seeking'; // Go back to seeking/idle behavior
                        this.speed = this.baseSpeed; // Reset speed
                        // Seeking/Idle movement will be handled in the else block below for this frame
                        moveDescription = "Target Lost -> Seeking/Idle";
                    } else {
                        // 2. Move Towards Target & Check Collision
                        moveDescription = "Attacking";
                        const targetX = this.targetBall.x;
                        const targetY = this.targetBall.y;
                        const dx = targetX - this.x;
                        const dy = targetY - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        this.speed = this.baseSpeed * 1.5; 

                        if (distance < 10) { // Increased hit distance slightly
                             console.log(`Bee ${this.element?.id || 'N/A'} hit target Ball! Switching to Exiting.`);
                             
                             // Process ball hit
                             let ballDestroyed = false;
                             if(this.targetBall.takeDamage()) { 
                                this.targetBall.createExplosion();
                                this.targetBall.destroy(); 
                                // Ensure removal from balls array if destroy didn't handle it
                                const ballArrayIndex = balls.indexOf(this.targetBall);
                                if(ballArrayIndex > -1) balls.splice(ballArrayIndex, 1); 
                                ballDestroyed = true;
                             }
                            
                            // Clear target reference and flag LAST
                            this.targetBall.isTargetedByBee = false; 
                            this.targetBall = null; 
                            
                            // Change bee state and speed for exit
                            this.state = 'exiting';
                            this.speed = this.baseSpeed * 2; // Faster exit speed
                            moveDescription = "Hit Target -> Exiting";
                            // --- Bee continues to move in this frame, handled by 'exiting' state below --- 

                        } else {
                            // Move towards target (Attacking)
                            this.x += (dx / distance) * this.speed;
                            this.y += (dy / distance) * this.speed;
                        }
                    }
                } 

                // Handle Exiting state
                else if (this.state === 'exiting') {
                    moveDescription = 'Exiting';
                    this.y -= this.speed; // Move straight up
                    // Optional: Add slight horizontal drift back?
                    // this.x += this.drift * 0.2;

                    // Check if off-screen top during exit
                    const topBoundary = gameAreaTop; 
                    if (this.y + this.size < topBoundary) { 
                        console.log(`Bee ${this.element?.id || 'N/A'} destroyed (Exited screen top)`); 
                        this.destroy(); 
                        return; // Stop further processing for this destroyed bee
                    } 
                }
                
                // Handle Seeking/Idle state 
                else if (this.state === 'seeking' || this.state === 'idle') { 
                     // ... (Seeking/Idle logic remains the same) ...
                     moveDescription = this.state; // Set description based on current state
                    const targetX = this.idleTargetX;
                    const targetY = this.idleTargetY;
                    const dx = targetX - this.x;
                    const dy = targetY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    this.speed = this.baseSpeed; // Use base speed for idle

                    if (distance < 15) { // Close enough to idle target
                        this.setNewIdleTarget(); // Get a new patrol point
                    } else {
                        // Move towards idle target
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    }
                }
                // --------------------------

                // Update element position (if not destroyed during exit check)
                if (this.element) {
                    this.element.style.top = `${this.y}px`;
                    this.element.style.left = `${this.x}px`;
                }

                // General Off-screen Check (redundant if handled in Exiting state? Keep as failsafe for now?)
                // Let's remove this for now, rely on the Exiting state check.
                /*
                const topBoundary = gameAreaTop; 
                if (this.state !== 'attacking' && this.y + this.size < topBoundary) { 
                    console.log(`Bee ${this.element?.id || 'N/A'} destroyed (Off-screen top - Failsafe)`); 
                    this.destroy(); 
                }
                */
            }

            checkCollision(ball) {
                // Requires ball.x, ball.y, ball.size
                const dx = this.x - ball.x;
                const dy = this.y - ball.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                // Check if distance is less than sum of radii (approximate)
                return distance < (this.size / 2 + ball.size / 2);
            }

            destroy() {
                // Clear target flag on the ball if this bee had one
                if (this.targetBall) {
                    console.log(`Bee ${this.element?.id || 'N/A'} destroyed, clearing target flag on ball.`);
                    this.targetBall.isTargetedByBee = false;
                    this.targetBall = null; // Clear own reference
                }
                // Original destroy logic
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                    this.element = null;
                }
            }
        }

        const balls = [];
        const lasers = [];
        const aliens = [];
        const bonuses = []; // Array to hold active bonus boxes
        const bees = []; 

        function createAlien() {
            // Place alien relative to game area boundaries
            const x = gameAreaLeft + (gameAreaRight - gameAreaLeft) / 3; // Approx 1/3 across game area
            const y = gameAreaTop - ALIEN_SIZE / 2; // Position top edge slightly above game area top
            const baseSpeed = 5 * (GAME_WIDTH / 1500);
            const speed = baseSpeed * (1 + (gameLevel - 1) * 0.12); 
            const alien = new Alien(ALIEN_SIZE, getRandomColor(), x, y, speed);
            alien.create();
            aliens.push(alien);
        }

        function calculateAngleToTarget(startX, startY, targetX, targetY) {
            const dx = targetX - startX;
            const dy = targetY - startY;
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            return angle;
        }

        function calculateBankShot(startX, startY, targetX, targetY) {
            const useLeftWall = Math.random() < 0.5;
            // Use game area boundaries for wall X
            const wallX = useLeftWall ? gameAreaLeft : gameAreaRight;
            
            const dx = targetX - wallX;
            const dy = targetY - startY;
            const wallY = startY + (dy / 2);  
            
            // Use game area boundaries for wall Y clamping
            const minWallY = gameAreaTop;
            const maxWallY = gameAreaBottom;
            const clampedWallY = Math.max(minWallY, Math.min(maxWallY, wallY));
            
            const angleToWall = calculateAngleToTarget(startX, startY, wallX, clampedWallY);
            return angleToWall;
        }

        function createBall(shotType = 'random', ballType = 'standard') {
            // Level 1 - 10 ball max, Level 2 : 14 ball max, level 3 : 
            if (balls.length > cMAXBALLS + ((gameLevel - 1) * (2 * gameLevel))) {
                console.log("Ball Count=" + balls.length)
                return;
            }

            // Position ball start relative to alien center and game area top
            const alien = aliens[0]; // Get alien reference
            if (!alien) return; // Don't create if alien doesn't exist

            const alienCenterX = alien.x + alien.size / 2;
            const alienCenterY = alien.y + alien.size / 2; // <<< USE CURRENT ALIEN Y
            const x = alienCenterX;
            const y = alienCenterY; 
            const speed = 5 * (GAME_WIDTH / 1500);

            // Get flower positions
            const flowers = document.getElementsByClassName('static-flower');
            if (flowers.length > 0) {
                // Randomly select a flower to target
                const targetIndex = Math.floor(Math.random() * flowers.length);
                const flowerRect = flowers[targetIndex].getBoundingClientRect();
                const targetX = flowerRect.left + (flowerRect.width / 2);
                const targetY = flowerRect.top + (flowerRect.height / 2);

                let angle;
                // Determine shot type based on parameter

                if (shotType === 'random') {
                    // 50% chance for direct shot vs bank shot
                    shotType = Math.random() < 0.5 ? 'direct' : 'bank';
                }

                if (shotType === 'direct') {
                    angle = calculateAngleToTarget(x, y, targetX, targetY);
                } else {
                    // shotType === 'bank'
                    angle = calculateBankShot(x, y, targetX, targetY);
                }
                
                // If ballType is 'random', decide which type to create
                if (ballType === 'random') {
                    // The higher the level, the more likely we are to get armored balls
                    const armoredChance = 0.3 + (gameLevel - 1) * 0.05; // 10% at level 1, increases by 5% per level
                    ballType = Math.random() < armoredChance ? 'armored' : 'standard';
                }
                
                // Create ball with calculated angle and specified type
                const ball = new Ball(BALL_SIZE, getRandomColor(), x, y, speed, angle, ballType);
                ball.create("");
                balls.push(ball);
            }
        }


        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function moveAlien() {
            if (isGamePaused) return;
            aliens[0].move();
        }

        function moveBalls() {

            for (let i = 0; i < balls.length; i++) {
                balls[i].move();
            }
        }

        // Player movement
        const player = document.getElementById('player');
        let playerX = WINDOW_WIDTH / 2;
        player.style.bottom = `${BORDER_MARGIN + BOTTOM_BORDER_OFFSET - 25}px`;
        player.style.left = `${playerX}px`;
        let isMovingLeft = false;
        let isMovingRight = false;
        // New variables for smoother movement
        let playerSpeed = 0;
        const MAX_PLAYER_SPEED = 8;
        const ACCELERATION = 0.5;
        const DECELERATION = 0.8;

        document.addEventListener('keydown', function (event) {
            if (event.key === 'ArrowLeft') {
                isMovingLeft = true;
            } else if (event.key === 'ArrowRight') {
                isMovingRight = true;
            } else if (event.key === '1') { // <<< ADDED: Check for '1' key
                launchBeeSwarm(); // Launch bees
            }
        });

        document.addEventListener('keyup', function (event) {
            if (event.key === 'ArrowLeft') {
                isMovingLeft = false;
            } else if (event.key === 'ArrowRight') {
                isMovingRight = false;
            }
        });

        function updatePlayer() {
            if (isGamePaused) return;
            
            // Apply acceleration/deceleration for smoother movement
            if (isMovingLeft && !isMovingRight) {
                playerSpeed = Math.max(-MAX_PLAYER_SPEED, playerSpeed - ACCELERATION);
            } else if (isMovingRight && !isMovingLeft) {
                playerSpeed = Math.min(MAX_PLAYER_SPEED, playerSpeed + ACCELERATION);
            } else {
                if (playerSpeed > 0) {
                    playerSpeed *= DECELERATION;
                    if (playerSpeed < 0.1) playerSpeed = 0;
                } else if (playerSpeed < 0) {
                    playerSpeed *= DECELERATION;
                    if (playerSpeed > -0.1) playerSpeed = 0;
                }
            }
            
            // Apply player speed
            playerX += playerSpeed;

            // Player visual width calculation
            const playerVisualWidth = PLAYER_SIZE * 0.6; 
            const playerVisualOffset = playerVisualWidth / 2;

            // Constrain player horizontal movement
            playerX = Math.max(gameAreaLeft + playerVisualOffset, 
                             Math.min(playerX, gameAreaRight - playerVisualOffset));
                             
            // Update player style
            player.style.left = playerX + 'px';
            // Keep bottom position fixed relative to gameAreaBottom
            // No need to update bottom every frame unless it changes dynamically
            // player.style.bottom = `${WINDOW_HEIGHT - gameAreaBottom + 10}px`; // Usually set only once
        }

        // Window resize handling
        window.addEventListener('resize', function() {
            
            setCharacterSizes(); 

            // Update canvas size
            canvas.width = WINDOW_WIDTH;
            canvas.height = WINDOW_HEIGHT;

            // Update element sizes
            document.getElementById('player').style.fontSize = `${PLAYER_SIZE}px`;
            document.getElementById('Alien').style.fontSize = `${ALIEN_SIZE}px`;
            document.getElementById('score').style.fontSize = `${Math.min(WINDOW_WIDTH, WINDOW_HEIGHT) * 0.08}px`;
            document.getElementById('score').style.top = '30px';

            // Redraw border
            draw();
            
        });

        
        // Laser firing
        cMAX_LASERS_AT_ONCE = 5
       
        document.addEventListener('keydown', function (event) {
            if (event.key === ' ' && !isGamePaused) {
                if (lasers.length < cMAX_LASERS_AT_ONCE) {
                    // Position laser start at the player's current visual center
                    const playerRect = player.getBoundingClientRect(); // Get player position
                    const laserStartX = playerRect.left + playerRect.width / 2; // Horizontal center
                    const laserStartY = playerRect.top; // Start at the visual top of the player 
                    
                    const laser = new Laser(laserStartX, laserStartY);
                    laser.create();
                    lasers.push(laser);
                    
                    LASER_SOUND.currentTime = 0; 
                    LASER_SOUND.play();
                    
                    // Energy effect at bottom when firing
                    const xPosition = playerX / WINDOW_WIDTH;
                   
                    applyBorderEffect('border-bottom-left', 'energy', 500); // Target DIV ID
                    applyBorderEffect('border-bottom-right', 'energy', 500); // Target DIV ID
                   
                }
            }
        });

        // Separate laser movement and collision detection into its own function
        function moveLasers() {
          
            if (isGamePaused) return;
            
            for (let i = 0; i < lasers.length; i++) {
                const laser = lasers[i];
                laser.move();
                
                // Define laser tip coordinates for clarity
                const laserTipX = laser.x; 
                const laserTipY = laser.y;
                
                // Check for alien collision (Point-in-Rect check)
                if (aliens.length > 0 && !aliens[0].isDefeated) {
                    const alien = aliens[0];
                    // Check if laser tip is within the alien's bounding box
                    // Note: Alien position (alien.x, alien.y) is top-left. 
                    // Alien size is alien.size.
                    if (laserTipX >= alien.x && laserTipX <= alien.x + alien.size &&
                        laserTipY >= alien.y && laserTipY <= alien.y + alien.size) 
                    {
                    laser.destroy();
                    lasers.splice(i, 1);
                        i--; // Adjust index after removal
                    
                        // ... (ball creation logic remains the same) ...
                         const armoredChance = Math.min(0.3, 0.1 + (gameLevel - 1) * 0.05); 
                    
                    if (Math.random() < armoredChance) {
                            createBall("bank", "armored"); 
                            createBall("bank", "standard");
                    } else {
                            createBall("bank", "standard");
                        createBall("bank", "standard");
                    }

                        alien.takeDamage();  // Decrease alien health
                   
                        // Optional: applyBorderEffect('border-top', 'flash'); // Use new border div if needed
                   
                        score += 5; 
                    SPACESHIP_HIT_SOUND.currentTime = 0; 
                    SPACESHIP_HIT_SOUND.play(); 
                    
                    applyBorderEffect('topBorderOverlay', 'particles', 2000);

                    document.getElementById('score').innerHTML = score.toString();
                        alien.flash(); 
                        continue; // Skip ball collision check for this laser
                    }
                }
                
                // Check for laser / ball collisions
                // Ball.isColliding uses center-to-center distance, which is correct.
                // We pass the laser tip (x, y) and a small radius/hitbox size.
                // Ensure index `i` is still valid after potential alien hit removal
                if (i < 0 || i >= lasers.length) continue; 
                
                for (let j = 0; j < balls.length; j++) {
                    const ball = balls[j];
                    // Pass laserTipX, laserTipY which represent the laser's top-center point
                    if (ball.isColliding(laserTipX, laserTipY, LASER_HITBOX_WIDTH)) { 
                        const isDestroyed = ball.takeDamage();
                        
                        laser.destroy();
                        lasers.splice(i, 1);
                        i--; // Adjust index after removing laser
                        
                        if (isDestroyed) {
                            ball.createExplosion();
                            ball.destroy();
                            balls.splice(j, 1);
                            j--; // Adjust index after removing ball
                            
                            if (ball.type === 'armored') {
                                score += 3;
                                // Optional: applyBorderEffect('border-top', 'particles', 1000); 
                                ARMORED_DEFEAT_SOUND.currentTime = 0;
                                ARMORED_DEFEAT_SOUND.play();
                            } else {
                                score += 1;
                            }
                        } else {
                            // Optional: applyBorderEffect('border-right', 'glow', 500);
                            ARMORED_HIT_SOUND.currentTime = 0;
                            ARMORED_HIT_SOUND.play();
                        }
                        
                        document.getElementById('score').innerHTML = score.toString();
                        break; // Laser hit a ball, move to next laser
                    }
                }
                
                // Check for laser / bonus collisions
                // Ensure laser index `i` is still valid after potential alien/ball hit removal
                if (i < 0 || i >= lasers.length) continue; 

                for (let k = bonuses.length - 1; k >= 0; k--) {
                    const bonus = bonuses[k];
                    if (!bonus || !bonus.element) continue; // Skip if bonus already destroyed

                    // Simple bounding box check: laser tip vs bonus box
                    const bonusRect = bonus.element.getBoundingClientRect(); 
                    // Use laserTipX, laserTipY which are the top-center of the laser beam
                    if (laserTipX >= bonusRect.left && 
                        laserTipX <= bonusRect.right &&
                        laserTipY >= bonusRect.top && 
                        laserTipY <= bonusRect.bottom)
                    {
                        bonus.hit(); // Handle bonus collection (awards points, plays sound, removes bonus from array)
                        // bonuses.splice(k, 1); // Removal is now handled inside bonus.hit()

                        laser.destroy(); // Destroy the laser
                        lasers.splice(i, 1); // Remove laser from array
                        i--; // Adjust laser index

                        // TODO: Play bonus collect sound here? (Or confirm it's in bonus.hit())
                        
                        break; // Laser hit a bonus, move to next laser
                    }
                }

                // Remove lasers that go off screen (using gameAreaTop)
                // Ensure index `i` is still valid after potential ball/bonus hit removal
                if (i >= 0 && i < lasers.length && laserTipY <= gameAreaTop) { 
                    laser.destroy();
                    lasers.splice(i, 1);
                    i--; // Adjust index after removal
                }
            }
        }

        // ******* end of Laser Movement and Collision **************
        const CANVAS = document.getElementsByTagName("canvas")[0],
            CTX = CANVAS.getContext("2d"),
            W = GAME_WIDTH,
            H = GAME_HEIGHT,
            XO = W / 2 + BORDER_MARGIN,
            YO = H / 2 + BORDER_MARGIN,
            PARTICLES = [];
            
        // Call once on page load to start the animation
        init();
        
        function init() {
            // Initial canvas setup - Use current window dimensions directly
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;

            // We will calculate final sizes later in initializeGame after fonts load
            // setCharacterSizes(); // Remove this initial call

            // Create particles if enabled (might need adjustment if dependent on precise sizes)
            if (cPARTICLES) { 
                // If particle creation relies heavily on BORDER_MARGIN etc, 
                // it might need to move into the initializeGame async block too.
                // For now, assume it's okay here.
            createParticles();
            loop();
            }
            
            // Do not draw initially here, wait for initializeGame
            // draw(); 
        }

        function loop() {
            requestAnimationFrame(loop);
            
            CTX.save();
            
            // Clip to exact inner border boundaries, accounting for bottom border
            CTX.beginPath();
            CTX.rect(BORDER_MARGIN + BORDER_OFFSET, 
                    BORDER_MARGIN + BORDER_OFFSET, 
                    GAME_WIDTH - (2 * BORDER_OFFSET),  // Adjusted width to not overlap borders
                    GAME_HEIGHT - (2 * BORDER_OFFSET) - (BOTTOM_BORDER_WIDTH - BORDER_WIDTH));
            CTX.clip();
            
            // Clear previous frame completely
            CTX.clearRect(BORDER_MARGIN + BORDER_OFFSET, 
                        BORDER_MARGIN + BORDER_OFFSET, 
                        GAME_WIDTH - (2 * BORDER_OFFSET), 
                        GAME_HEIGHT - (2 * BORDER_OFFSET) - (BOTTOM_BORDER_WIDTH - BORDER_WIDTH));
            
            // Background for depth (completely black)
            CTX.fillStyle = "rgba(0,0,0,1)";
            CTX.fillRect(BORDER_MARGIN + BORDER_OFFSET, 
                        BORDER_MARGIN + BORDER_OFFSET, 
                        GAME_WIDTH - (2 * BORDER_OFFSET), 
                        GAME_HEIGHT - (2 * BORDER_OFFSET) - (BOTTOM_BORDER_WIDTH - BORDER_WIDTH));
            
            
            // Always render particles
            render();
            
            
            CTX.restore();
                
           
        }

        function createParticles() {
            PARTICLES.length = 0; // Clear any existing particles
            // Create a lot more particles for a denser star field
            const particleCount = Math.floor((WINDOW_WIDTH * WINDOW_HEIGHT) / 2000);
            for (let i = 0; i < particleCount; i++) {
                PARTICLES.push(new Particle());
            }
        }

             
        // Add pause button functionality
        const pauseButton = document.getElementById('pauseButton');
        pauseButton.style.bottom = `${BORDER_MARGIN + BORDER_OFFSET - 50}px`;
        
        // Add unified pause/unpause functions
        function pauseGame(playerPaused = false) {
            isGamePaused = true;
            pauseButton.textContent = '▶️'; // Play symbol
            
            // Clear all intervals
            if (gameIntervals) {
                for (let interval in gameIntervals) {
                    clearInterval(gameIntervals[interval]);
                    gameIntervals[interval] = null; // Set to null to ensure GC
                }
                // Explicitly clear potential lingering references if object wasn't fully cleared
                gameIntervals.createBall = null;
                gameIntervals.moveBalls = null;
                gameIntervals.moveAlien = null;
                gameIntervals.updatePlayer = null;
                gameIntervals.moveLasers = null;
                gameIntervals.createBonus = null; 
                gameIntervals.moveBonuses = null;
                gameIntervals.moveBees = null; // Clear bee interval
            }
            
            if (playerPaused) {
                BACKGROUND_MUSIC.pause();  // Pause the music
            }
           
        }
        function unpauseGame() {
            // Always make sure to clear any existing intervals first
            if (gameIntervals) {
                for (let interval in gameIntervals) {
                    clearInterval(gameIntervals[interval]);
                    gameIntervals[interval] = null;
                }
            }
            
            isGamePaused = false;
            pauseButton.textContent =  '⏸️'; // Pause symbol
            
            // Restart all game intervals with adjusted speeds
            gameIntervals = {
                createBall: setInterval(createBall, 2000),
                moveBalls: setInterval(moveBalls, 20),
                moveAlien: setInterval(moveAlien, 20),
                updatePlayer: setInterval(updatePlayer, 10),
                moveLasers: setInterval(moveLasers, 15), 
                createBonus: setInterval(createBonus, 5000), // Create a bonus every 5 seconds
                moveBonuses: setInterval(moveBonuses, 20),   // Move bonuses at same rate as balls
                moveBees: setInterval(moveBees, 25) // Move bees 
            };
            
            BACKGROUND_MUSIC.play();  // Resume the music
        }
        function levelUp() {
            // Always make sure to clear any existing intervals first
            gameLevel++;
            
            if (gameIntervals) {
                for (let interval in gameIntervals) {
                    clearInterval(gameIntervals[interval]);
                    gameIntervals[interval] = null;
                }
            }
            
            isGamePaused = false;
            pauseButton.textContent =  '⏸️'; // Pause symbol
            
            // Get updated speed values based on current level
            const baseSpeed = 5 * (GAME_WIDTH / 1500);
            const alienSpeed = baseSpeed * (1 + (gameLevel - 1) * 0.2); // Increase alien speed by 20% per level
            const ballSpeed = baseSpeed * (1 + (gameLevel - 1) * 0.15); // Increase ball speed by 15% per level
            
            // Create the alien for the current level if it doesn't exist
            if (aliens.length === 0) {
                // Create a new alien with updated speed
                createAlien();
                document.getElementById('alienHealthContainer').style.display = 'block';
            } else {
                // Reposition existing alien to center of screen
                const centerX = (GAME_WIDTH / 2) - (aliens[0].size / 2) + BORDER_MARGIN;
                aliens[0].x = centerX;
                aliens[0].element.style.left = centerX + 'px';
                aliens[0].element.style.top = (BORDER_MARGIN + BORDER_OFFSET) + 'px';
                
                // Reset alien classes to remove defeat animation if present
                aliens[0].element.className = 'alien';
                
                aliens[0].y =  aliens[0].initialY; 
                aliens[0].isBerserk = false; 
                
                // Reset health
                aliens[0].health = cTEST_MODE ? 20 : 100 
                document.getElementById('alienHealthBar').style.width = '100%';
                document.getElementById('alienHealthContainer').style.display = 'block';
            }
            
            // Restart all game intervals with adjusted speeds
            gameIntervals = {
                createBall: setInterval(() => {
                    // As levels progress, increase chance of creating armored balls
                    const armoredChance = Math.min(0.3, 0.05 + (gameLevel - 1) * 0.05); // Up to 30% max
                    
                    if (Math.random() < armoredChance && gameLevel > 1) {
                        createBall("random", "armored");
                    } else {
                        createBall("random", "standard");
                    }
                }, 2000),
                moveBalls: setInterval(moveBalls, 20),
                moveAlien: setInterval(moveAlien, 20),
                updatePlayer: setInterval(updatePlayer, 10),
                moveLasers: setInterval(moveLasers, 15),
                createBonus: setInterval(createBonus, 5000), // Create a bonus every 5 seconds
                moveBonuses: setInterval(moveBonuses, 20),   // Move bonuses at same rate as balls
                moveBees: setInterval(moveBees, 25) // Move bees 
            };
            
            BACKGROUND_MUSIC.play();  // Resume the music
        }

        pauseButton.addEventListener('click', function() {
            if (isGamePaused) {
                unpauseGame();
            } else {
                pauseGame(true);
            }
        });

        // Modify movement functions to respect pause state
        function moveBalls() {
            if (isGamePaused) return;
            for (let i = 0; i < balls.length; i++) {
                balls[i].move();
            }
        }

        function moveAlien() {
            if (isGamePaused) return;
            aliens[0].move();
        }

        function updatePlayer() {
            if (isGamePaused) return;
            
            // Apply acceleration/deceleration for smoother movement
            if (isMovingLeft && !isMovingRight) {
                playerSpeed = Math.max(-MAX_PLAYER_SPEED, playerSpeed - ACCELERATION);
            } else if (isMovingRight && !isMovingLeft) {
                playerSpeed = Math.min(MAX_PLAYER_SPEED, playerSpeed + ACCELERATION);
            } else {
                if (playerSpeed > 0) {
                    playerSpeed *= DECELERATION;
                    if (playerSpeed < 0.1) playerSpeed = 0;
                } else if (playerSpeed < 0) {
                    playerSpeed *= DECELERATION;
                    if (playerSpeed > -0.1) playerSpeed = 0;
                }
            }
            
            // Apply player speed
            playerX += playerSpeed;

            // Player visual width calculation
            const playerVisualWidth = PLAYER_SIZE * 0.6; 
            const playerVisualOffset = playerVisualWidth / 2;

            // Constrain player horizontal movement
            playerX = Math.max(gameAreaLeft + playerVisualOffset, 
                             Math.min(playerX, gameAreaRight - playerVisualOffset));
                             
            // Update player style
            player.style.left = playerX + 'px';
            // Keep bottom position fixed relative to gameAreaBottom
            // No need to update bottom every frame unless it changes dynamically
            // player.style.bottom = `${WINDOW_HEIGHT - gameAreaBottom + 10}px`; // Usually set only once
        }

        // Add game over function
        function endGame() {
            isGamePaused = true;
            
            // Clear all intervals
            for (let interval in gameIntervals) {
                clearInterval(gameIntervals[interval]);
            }

            // Hide player and alien
            document.getElementById('player').style.display = 'none';
            if (aliens.length > 0 && aliens[0].element) {
                aliens[0].element.style.display = 'none';
            }
            
            // Hide health bar
            document.getElementById('alienHealthContainer').style.display = 'none';

            // Clear any existing lasers
            while(lasers.length > 0) {
                const laser = lasers.pop();
                laser.destroy();
            }
            
            // Clear any existing balls
            while(balls.length > 0) {
                const ball = balls.pop();
                ball.destroy();
            }

            // Clear any existing bonuses
            while(bonuses.length > 0) { 
                const bonus = bonuses.pop();
                bonus.destroy();
            }

            // Clear any existing bees & reset beehive state
            while(bees.length > 0) {
                const bee = bees.pop();
                bee.destroy();
            }
             beehiveReady = true; // Reset readiness
            if (beehiveIconElement) {
                beehiveIconElement.classList.remove('cooldown'); // Remove cooldown style
                beehiveIconElement.innerHTML = '&#x1F41D;'; // Ensure bee icon
            }

            BACKGROUND_MUSIC.pause();  // Stop the music

            // Show game over screen
            document.getElementById('gameOverContainer').style.display = 'block';
        }

        // Add play again button listener
        document.getElementById('playAgainButton').addEventListener('click', restartGame);

        // Add sound effect for flower hits
        function createFlowerDeathAnimation(flower) {
            // Play the hit sound
            FLOWER_HIT_SOUND.currentTime = 0;  // Reset sound to start
            FLOWER_HIT_SOUND.play();

            const flowerRect = flower.getBoundingClientRect();
            const flowerX = flowerRect.left + flowerRect.width/2;
            const flowerY = flowerRect.top + flowerRect.height/2;
            
            // Create container for the petals
            const petalContainer = document.createElement('div');
            petalContainer.style.position = 'absolute';
            petalContainer.style.left = flowerX + 'px';
            petalContainer.style.top = flowerY - 5 + 'px';
            petalContainer.style.zIndex = '1000';
            
            // Create multiple petals
            const numPetals = 8;
            const petalEmojis = ['🌸', '🌺', '🌹']; // Petal options
            
            for (let i = 0; i < numPetals; i++) {
                const petal = document.createElement('div');
                petal.className = 'petal';
                petal.textContent = petalEmojis[Math.floor(Math.random() * petalEmojis.length)];
                
                // Calculate random direction and rotation for each petal
                const angle = (i / numPetals) * 360 + Math.random() * 30;
                const distance = 100 + Math.random() * 50;
                const tx = Math.cos(angle * Math.PI / 180) * distance;
                const ty = Math.sin(angle * Math.PI / 180) * distance + 100; // Add extra downward motion
                const rotation = Math.random() * 360;
                
                petal.style.setProperty('--tx', `${tx}px`);
                petal.style.setProperty('--ty', `${ty}px`);
                petal.style.setProperty('--rotation', `${rotation}deg`);
                
                petalContainer.appendChild(petal);
            }
            
            document.body.appendChild(petalContainer);
            
            // Remove container after animation
            setTimeout(() => {
                if (petalContainer.parentNode) {
                    petalContainer.parentNode.removeChild(petalContainer);
                }
            }, 1500);
        }
       
        function init() {
            CANVAS.width = W;
            CANVAS.height = H;
            if (cPARTICLES) { 
                createParticles();
            loop();
            }
            
        }

        // Only initialize canvas and background particles
        init();

        // Add function to create decorative flowers
        function createDecorativeFlowers() {
            const flowerRow = document.getElementById('decorativeFlowerRow');
            const screenWidth = window.innerWidth;
            const flowerWidth = 60;  // Approximate width of each flower emoji with spacing
            const numFlowers = 9;
            
            for (let i = 0; i < numFlowers; i++) {
                const flower = document.createElement('span');
                if (i % 2 === 0) {
                    flower.innerHTML = '&#x1F337;';  // Rose
                } else {
                    flower.innerHTML = '&#x1F33A;';  // Hibiscus
                }
                flowerRow.appendChild(flower);
            }
        }

        // Call this when the page loads
        createDecorativeFlowers();

        function showLevelComplete() {
            const container = document.getElementById('levelMessageContainer');
            // Clear any existing messages
            container.innerHTML = '';
            
            // Create a container for the "Level Complete!" message
            const completeMsgContainer = document.createElement('div');
            completeMsgContainer.className = 'message-container';
            container.appendChild(completeMsgContainer);
            
            // Create and show "Level Complete!" message
            const completeMsg = document.createElement('div');
            completeMsg.className = 'level-message';
            completeMsg.textContent = 'Level Complete!';
            completeMsg.style.animation = 'fadeInOut 2s forwards';
            completeMsgContainer.appendChild(completeMsg);

            // After 2 seconds, show next level message in its own container
            setTimeout(() => {
                // Clear previous messages
                container.innerHTML = '';
                
                // Create a new container for the next level message
                const nextLevelContainer = document.createElement('div');
                nextLevelContainer.className = 'message-container';
                container.appendChild(nextLevelContainer);
                
                const nextLevelMsg = document.createElement('div');
                nextLevelMsg.className = 'level-message';
                nextLevelMsg.textContent = `Level ${gameLevel + 1}`;
                // Use the fadeInStay animation that remains visible
                nextLevelMsg.style.animation = 'fadeInStay 0.5s forwards';
                nextLevelContainer.appendChild(nextLevelMsg);

                // Remove messages and unpause game
                setTimeout(() => {
                    container.innerHTML = '';
                    levelUp();  // Use the unified unpause function
                    console.log("Level Up Complete")
                }, 2000);
            }, 2000);
            aliens[0].isDefeated = false; 
        }

        

        // Utility function to apply effects to border overlays
        function applyBorderEffect(overlayId, effect, duration = 2000) {
            const overlay = document.getElementById(overlayId);
            if (!overlay) return;
            
            // Reset specific styles potentially used by effects, NOT innerHTML
            overlay.style.transition = '';
            overlay.style.boxShadow = '';
            overlay.style.backgroundImage = ''; // Reset background image if used by energy effect
            overlay.style.animation = ''; // Reset animation if used
            // Remove any leftover particle elements if that effect was used
            const existingParticles = overlay.querySelectorAll('.border-particle');
            existingParticles.forEach(p => p.remove());

            // REMOVED: overlay.innerHTML = ''; 

            switch (effect) {
                case 'flash':
                    // Flash effect - brighten the existing background
                    const currentBg = window.getComputedStyle(overlay).backgroundColor;
                    overlay.style.transition = 'background-color 0.2s ease-in-out';
                    overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.7)'; // Brighter flash
                    setTimeout(() => {
                        // Restore the original background from CSS
                        overlay.style.backgroundColor = '';
                    }, 200);
                    break;
                    
                case 'glow':
                    // Glow effect
                    overlay.style.transition = 'box-shadow 0.5s ease-in-out';
                    overlay.style.boxShadow = 'inset 0 0 20px rgba(255, 215, 0, 0.6)';
                    setTimeout(() => {
                        overlay.style.boxShadow = '';
                    }, duration);
                    break;
                    
                case 'particles':
                    // Particle effect
                    const particleCount = Math.floor(overlay.offsetWidth * overlay.offsetHeight / 5000);
                    for (let i = 0; i < particleCount; i++) {
                        const particle = document.createElement('div');
                        particle.className = 'border-particle';
                        particle.style.position = 'absolute';
                        particle.style.width = '3px';
                        particle.style.height = '3px';
                        particle.style.backgroundColor = 'gold';
                        particle.style.borderRadius = '50%';
                        particle.style.left = `${Math.random() * 100}%`;
                        particle.style.top = `${Math.random() * 100}%`;
                        particle.style.opacity = Math.random();
                        particle.style.animation = `fadeOut ${Math.random() * 1.5 + 0.5}s linear`;
                        overlay.appendChild(particle);
                    }
                    setTimeout(() => {
                        const particles = overlay.querySelectorAll('.border-particle');
                        particles.forEach(p => p.remove());
                    }, duration);
                    break;
                    
                case 'warning':
                    // Warning effect (red pulsing)
                    // overlay.style.animation = 'pulsateRed 0.5s infinite alternate'; // REMOVE old animation
                    // Apply a red outer glow instead
                    overlay.style.boxShadow = '0 0 25px 10px rgba(255, 0, 0, 0.7)'; // Red glow
                    overlay.style.transition = 'box-shadow 0.1s ease-in-out'; // Add quick transition
                    setTimeout(() => {
                        // overlay.style.animation = ''; // No longer needed
                        overlay.style.boxShadow = ''; // Remove the glow
                    }, duration);
                    break;
                    
                case 'energy':
                    // Energy charge effect
                    // Increased opacity from 0.2 to 0.8 for visibility
                    overlay.style.backgroundImage = 'linear-gradient(to bottom, transparent, rgba(0, 255, 255, 0.8), transparent)';
                    overlay.style.backgroundSize = '100% 50px';
                    overlay.style.backgroundRepeat = 'repeat-y';
                    overlay.style.backgroundPosition = '0 -50px';
                    overlay.style.animation = 'energyFlow 1s infinite linear';
                    setTimeout(() => {
                        overlay.style.backgroundImage = '';
                        overlay.style.animation = '';
                    }, duration);
                    break;
            }
        }
        
        // Example usage:
        // applyBorderEffect('leftBorderOverlay', 'flash');
        //applyBorderEffect('rightBorderOverlay', 'glow', 3000);
        // applyBorderEffect('topBorderOverlay', 'particles', 2000);
        // applyBorderEffect('bottomLeftOverlay', 'warning', 1500);
        // applyBorderEffect('bottomRightOverlay', 'energy', 5000);

        // --- Mouse Boundary Test Function ---
        function handleMouseMove(event) {
            const mouseX = event.clientX;
            const mouseY = event.clientY;

            let location = "Outside"; // Default

            // 1. Check for main game area (Above the bottom border)
            if (mouseX > gameAreaLeft && mouseX < gameAreaRight && 
                mouseY > gameAreaTop && mouseY < gameAreaBottom) {
                location = "Inside Game Area";
            } 
            // 2. Check for bottom gap area (Below main area, within gap X)
            else if (mouseY >= gameAreaBottom && 
                     mouseX > gapStartX && mouseX < gapEndX) {
                location = "Inside Bottom Gap";
            }
            // 3. Check Border Regions (only if not in game area or gap)
            else if (mouseY <= gameAreaTop && mouseX >= gameAreaLeft && mouseX <= gameAreaRight) { 
                 location = "Top Border Area";
            }
            else if (mouseX <= gameAreaLeft && mouseY >= gameAreaTop && mouseY <= gameAreaBottom) { 
                 location = "Left Border Area";
            }
            else if (mouseX >= gameAreaRight && mouseY >= gameAreaTop && mouseY <= gameAreaBottom) { 
                 location = "Right Border Area";
            }
            // Check bottom left border area
            else if (mouseY >= gameAreaBottom && mouseX >= gameAreaLeft && mouseX <= gapStartX) { 
                 location = "Bottom Left Border Area";
            }
             // Check bottom right border area
            else if (mouseY >= gameAreaBottom && mouseX >= gapEndX && mouseX <= gameAreaRight) { 
                 location = "Bottom Right Border Area";
            }

            // Log only if location changes
            if (handleMouseMove.lastLocation !== location) {
                 console.log(`Mouse: (${mouseX}, ${mouseY}) - Location: ${location}`);
                 handleMouseMove.lastLocation = location;
            }
        }
        handleMouseMove.lastLocation = ""; // Initialize for change detection

        // Add the event listener
        if (cTEST_MODE) {
            document.addEventListener('mousemove', handleMouseMove);
        }
        // ----------------------------------

        // Function to create a new bonus object
        function createBonus() {
            if (isGamePaused) return; // Don't create if paused

            // Limit the number of bonuses on screen at once
            const maxBonuses = 3;
            if (bonuses.length >= maxBonuses) {
                return;
            }

            // Calculate a random vertical position within the main play area
            // Avoid spawning too close to the top or bottom borders
            const minY = gameAreaTop + BALL_SIZE; 
            // Restrict maxY to the top 50% of the game area
            const maxY = gameAreaTop + (gameAreaBottom - gameAreaTop) / 2; 
            const randomY = minY + Math.random() * (maxY - minY);

            const bonus = new Bonus(randomY);
            bonus.create();
            bonuses.push(bonus);
        }

        // Function to move all active bonuses
        function moveBonuses() {
            if (isGamePaused) return;
            // Iterate backwards to safely remove items while iterating
            for (let i = bonuses.length - 1; i >= 0; i--) {
                // Ensure the bonus still exists before moving (might have been hit)
                if (bonuses[i]) {
                    bonuses[i].move();
                }
                // Note: Off-screen removal is handled within Bonus.move()
            }
        }
        // Function to launch the bee swarm from the icon
        function launchBeeSwarm() {
            console.log("launchBeeSwarm function entered!"); // <<< ADD THIS LOG
          
            const now = Date.now();
            if (!beehiveReady || now < lastBeehiveTime + BEEHIVE_COOLDOWN) {
                console.log("Beehive on cooldown.");
                // Optionally provide visual feedback like a shake
                return;
            }

            beehiveReady = false;
            lastBeehiveTime = now;

            // Update icon visual state
            if (beehiveIconElement) {
                beehiveIconElement.classList.add('cooldown');
                // Change icon during cooldown?
                beehiveIconElement.innerHTML = '⏳'; 
            }

            // --- Start cooldown timer to reset readiness ---
            setTimeout(() => {
                console.log("COOLDOWN TIMER FINISHED: Resetting beehive state."); // <<< ADD LOG
                beehiveReady = true; // Set ready again
                if (beehiveIconElement) {
                    console.log("Attempting to remove cooldown class and reset icon."); // <<< ADD LOG
                    beehiveIconElement.classList.remove('cooldown'); // Remove cooldown style
                    // Restore icon to Bee, not satellite
                    beehiveIconElement.innerHTML = '&#x1F41D;'; 
                } else {
                    console.error("Beehive icon element lost before cooldown finished?"); // <<< ADD LOG
                }
                console.log("Beehive ready flag set to true!");
            }, BEEHIVE_COOLDOWN); // Timer runs for 15 seconds
            // ---------------------------------------------

            // --- Create the swarm ---
            const swarmSize = 8; // Number of bees
            if (!beehiveIconElement) {
                console.error("Cannot launch bees: Beehive icon element not cached.");
                return; // Can't proceed without the icon element
            }
            const iconRect = beehiveIconElement.getBoundingClientRect();
            const startX = iconRect.left + iconRect.width / 2;
            const startY = iconRect.top + iconRect.height / 2;

            for (let i = 0; i < swarmSize; i++) {
                // Add slight randomness to start position to avoid perfect stack
                const beeStartX = startX + (Math.random() - 0.5) * 10;
                const beeStartY = startY + (Math.random() - 0.5) * 10;
                console.log(`Creating bee ${i} at: X=${beeStartX.toFixed(2)}, Y=${beeStartY.toFixed(2)}`); // <<< LOG START COORDS
                const bee = new Bee(beeStartX, beeStartY);
                bee.create();
                bees.push(bee);
            }

            // TODO: Play bee launch sound
            // BEE_LAUNCH_SOUND.currentTime = 0;
            // BEE_LAUNCH_SOUND.play();

            console.log(`Launched ${swarmSize} bees.`);
        }

        // Function to move all active bees and check collisions
        function moveBees() {
            // console.log(`moveBees called. Paused=${isGamePaused}, BeeCount=${bees.length}`); // Keep logs minimal now
            if (isGamePaused) return;

            // --- Target Acquisition Phase ---
            const availableBalls = balls.filter(ball => !ball.isTargetedByBee);
            // ONLY consider bees currently in 'seeking' state for new targets
            const seekingBees = bees.filter(bee => bee.state === 'seeking'); // Was potentialSeekers

            let ballIndex = 0; 
            // Loop through bees that are actually seeking
            for (let bee of seekingBees) { // Use seekingBees
                if (availableBalls.length === 0 || ballIndex >= availableBalls.length) {
                    // No available balls left. Seeking bees will continue idle movement.
                    break; 
                }

                // Assign target
                const target = availableBalls[ballIndex];
                bee.targetBall = target;
                bee.state = 'attacking'; // Switch state to attacking
                target.isTargetedByBee = true;
                console.log(`Bee ${bee.element?.id || 'N/A'} assigned to target Ball.`);
                
                ballIndex++; 
            }
            // -----------------------------

            // --- Movement & Collision Phase --- 
            // Iterate backwards for safe removal during movement/collision checks
            for (let i = bees.length - 1; i >= 0; i--) {
                const bee = bees[i];
                if (!bee) continue; 

                bee.move(); // Bee.move now handles state logic & collisions

                // Check if bee was destroyed during its move() call (e.g., hit target or went off screen)
                if (!bees.includes(bee)) {
                    // Bee was destroyed and already removed itself (or should have)
                    // Need to ensure it's removed from the main array if destroy didn't
                     if (bees[i] === bee) { // Check if it wasn't already removed by splice in destroy
                         console.warn(`Bee was destroyed but maybe not removed from array in destroy? Splicing now.`);
                         bees.splice(i, 1);
                     }
                     continue; // Move to the next bee index
                }

                // Original Collision Check (Redundant if Bee.move handles it) 
                /*
                let hitBall = false;
                for (let j = balls.length - 1; j >= 0; j--) {
                    // ... existing collision logic ...
                }
                */
            }
            // -------------------------------
        }

    </script>
</body>


</html>