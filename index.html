<!doctype html>
<html>
  <head>
    <title>Flower Defense</title>
    <link rel="stylesheet" href="styles/flower_defense_stye.css" />
    <script src="scripts/particle.js"></script>
    <script src="scripts/Ball.js"></script>
    <script src="scripts/Saucer.js"></script>
    <script src="scripts/Laser.js"></script>
    <script src="scripts/Bee.js"></script>
    <script src="scripts/Rocket.js"></script>
    <script src="scripts/Bonus.js"></script>
  </head>
  <body>
    <canvas id="canvas" style="z-index: -2; position: absolute"></canvas>
    <!-- DIV Borders -->
    <div id="border-top" class="game-border"></div>
    <div id="border-left" class="game-border"></div>
    <div id="border-right" class="game-border"></div>
    <div id="border-bottom-left" class="game-border"></div>
    <div id="border-bottom-right" class="game-border">
      <!-- Beehive Button -->
      <button id="beehiveDefenseIcon" type="button">üêù</button>
      <!-- Rocket Launcher Indicator -->
      <div id="rocketLauncherIcon">
        <span class="rocket-emoji">üöÄ</span>
        <span id="rocketCount">5</span>
        <!-- Counter -->
      </div>
      <!-- Triple Laser Indicator -->
      <div id="tripleLaserIcon">
        <span class="tripleLaser-emoji">\|/</span>
        <span id="tripleLaserCount">40</span>
        <!-- Counter -->
      </div>
      <!-- Pause Button -->
      <button
        id="pauseButton"
        tabindex="-1"
        onkeydown="return event.key !== ' ' && event.code !== 'Space';"
      >
        ‚è∏Ô∏è
      </button>
    </div>
    <!-- End DIV Borders -->

    <div id="startGameContainer">
      <div id="startGameText">FLOWER DEFENSE</div>
      <button id="startGameButton">Start Game</button>
      <div id="controlsLegend">
        <div class="control-item">‚Üê ‚Üí <span>Move Sunflower</span></div>
        <div class="control-item">Space <span>Fire Laser</span></div>
        <div class="control-item">1 <span>Activate Bee Defense</span></div>
        <div class="control-item">Ctrl <span>Fire Rocket</span></div>
        <div class="control-item">z <span>Triple Lasers</span></div>
        <div class="control-item">P <span>Pause Game</span></div>
      </div>
      <div id="decorativeFlowerRow"></div>
    </div>

    <div id="score" class="score">0</div>
    <div id="player">&#x1F33B;</div>
    <div id="Saucer">&#x1f6f8;</div>
    <div id="saucerHealthContainer">
      <div id="saucerHealthBar"></div>
    </div>
    <div id="levelMessageContainer"></div>

    <!-- Add game over container -->
    <div id="gameOverContainer">
      <div id="gameOverText">GAME OVER</div>
      <button id="playAgainButton">Play Again</button>
    </div>
    <script>
        
      // Global variables for responsive sizing
      let WINDOW_WIDTH, WINDOW_HEIGHT, BORDER_MARGIN, GAME_WIDTH, GAME_HEIGHT
      let PLAYER_SIZE, BALL_SIZE, ALIEN_SIZE

      // Define Border Width Constants Globally and Early
      const BORDER_WIDTH = 60 // Reduced thickness
      const BOTTOM_BORDER_WIDTH = 120 // Reduced thickness
      const BORDER_OFFSET = BORDER_WIDTH / 2
      const BOTTOM_BORDER_OFFSET = BOTTOM_BORDER_WIDTH / 2

      // Global variables for Game Area Boundaries (derived from DIVs)
      let gameAreaTop, gameAreaLeft, gameAreaRight, gameAreaBottom
      let gapStartX, gapEndX // Coordinates for the gap edges

      cTEST_MODE = false
      const ALIEN_CREATION_INTERVAL_DECREASE = .90 // (10% decrease each level to produce aliens faster)
      const MIN_ALIEN_CREATION_INTERVAL = .4 // we won't produce aliens any faster than one per .4 seconds. 
      const BALL_SPEED_DIVISOR = 1500
      let createAlienInterval = 2000 // Starts at 2 seconds and is reduced slightly after each level up.
      const DIRECT_HIT_PERCENTAGE = .5 //Percentage of aliens launched that will target for a direct hit , vs bank shots 
      const SAUCER_LEVEL_SCALING = .15 // increase speed of saucer by this amount every level 
      const SAUCER_HEALTH_INCREASE = 20 //Health increase per level. 
      
  

      let gameLevel = 1
      let gameIntervals
      // Bee-related variables and constants

      let beehiveReady = true // Is the defense ready to use?
      const BEE_SWARM_SIZE = 16
      let lastBeehiveTime = 0 // Timestamp of last use
      const BEEHIVE_COOLDOWN = 15000 // 15 seconds cooldown
      let beehiveIconElement = null // Reference to the icon DOM element

      let rocketsRemaining = 0 // Initialize globally first
      let rocketsPerLevel = 5
      let tripleLasersRemaining = 0 // Initialize globally first
      let tripleLasersPerLevel = 40

      // This function will be called again if the window is resized
      function setCharacterSizes() {
        // Calculate core dimensions
        WINDOW_WIDTH = window.innerWidth
        WINDOW_HEIGHT = window.innerHeight
        BORDER_MARGIN = Math.min(WINDOW_WIDTH, WINDOW_HEIGHT) * 0.02
        GAME_WIDTH = WINDOW_WIDTH - BORDER_MARGIN * 2
        GAME_HEIGHT = WINDOW_HEIGHT - BORDER_MARGIN * 2
        // Keep player/ball/saucer sizes
        PLAYER_SIZE = Math.min(WINDOW_WIDTH, WINDOW_HEIGHT) * 0.1
        BALL_SIZE = Math.min(WINDOW_WIDTH, WINDOW_HEIGHT) * 0.07
        ALIEN_SIZE = Math.min(WINDOW_WIDTH, WINDOW_HEIGHT) * 0.15

        // --- Style the Border DIVs ---
        const topBorder = document.getElementById('border-top')
        const leftBorder = document.getElementById('border-left')
        const rightBorder = document.getElementById('border-right')
        const bottomLeftBorder = document.getElementById('border-bottom-left')
        const bottomRightBorder = document.getElementById('border-bottom-right')

        const centerGapWidth = 280 // Increased gap width for another flower
        const gapStartCalc = WINDOW_WIDTH / 2 - centerGapWidth / 2
        const gapEndCalc = WINDOW_WIDTH / 2 + centerGapWidth / 2

        if (topBorder) {
          topBorder.style.top = `${BORDER_MARGIN}px`
          topBorder.style.left = `${BORDER_MARGIN}px`
          topBorder.style.width = `${GAME_WIDTH}px`
          topBorder.style.height = `${BORDER_WIDTH}px`
        }
        if (leftBorder) {
          leftBorder.style.top = `${BORDER_MARGIN}px`
          leftBorder.style.left = `${BORDER_MARGIN}px`
          leftBorder.style.width = `${BORDER_WIDTH}px`
          leftBorder.style.height = `${GAME_HEIGHT}px` // Correct height based on game area
        }
        if (rightBorder) {
          rightBorder.style.top = `${BORDER_MARGIN}px`
          rightBorder.style.right = `${BORDER_MARGIN}px`
          rightBorder.style.width = `${BORDER_WIDTH}px`
          rightBorder.style.height = `${GAME_HEIGHT}px`
        }
        if (bottomLeftBorder) {
          bottomLeftBorder.style.bottom = `${BORDER_MARGIN}px`
          bottomLeftBorder.style.left = `${BORDER_MARGIN}px`
          bottomLeftBorder.style.width = `${gapStartCalc - BORDER_MARGIN}px` // Updated width to wider gap
          bottomLeftBorder.style.height = `${BOTTOM_BORDER_WIDTH}px` // Use new 160px
        }
        if (bottomRightBorder) {
          bottomRightBorder.style.bottom = `${BORDER_MARGIN}px`
          bottomRightBorder.style.right = `${BORDER_MARGIN}px`
          bottomRightBorder.style.width = `${WINDOW_WIDTH - gapEndCalc - BORDER_MARGIN}px` // Updated width from wider gap
          bottomRightBorder.style.height = `${BOTTOM_BORDER_WIDTH}px` // Use new 160px
        }
        // -----------------------------

        // --- Read DIV Boundaries into Global Variables ---
        if (
          topBorder &&
          leftBorder &&
          rightBorder &&
          bottomLeftBorder &&
          bottomRightBorder
        ) {
          // Use getBoundingClientRect for viewport-relative coordinates
          const topRect = topBorder.getBoundingClientRect()
          const leftRect = leftBorder.getBoundingClientRect()
          const rightRect = rightBorder.getBoundingClientRect()
          const blRect = bottomLeftBorder.getBoundingClientRect()
          const brRect = bottomRightBorder.getBoundingClientRect()

          // Calculate inner game area boundaries
          gameAreaTop = topRect.bottom
          gameAreaLeft = leftRect.right
          gameAreaRight = rightRect.left
          gameAreaBottom = blRect.top // Use top edge of bottom border
          gapStartX = blRect.right // Right edge of bottom-left defines gap start
          gapEndX = brRect.left // Left edge of bottom-right defines gap end

          console.log('Game Area Boundaries Updated:', {
            top: gameAreaTop,
            left: gameAreaLeft,
            right: gameAreaRight,
            bottom: gameAreaBottom,
            gapStart: gapStartX,
            gapEnd: gapEndX,
          })
        } else {
          console.error(
            'Could not find all border DIV elements to calculate boundaries.',
          )
        }
        // --------------------------------------------------------
      }

      // Call setCharacterSizes immediately to initialize values
      setCharacterSizes()

      // Hide game elements initially
      document.getElementById('score').style.display = 'none'
      document.getElementById('player').style.display = 'none'
      document.getElementById('Saucer').style.display = 'none'
      document.getElementById('pauseButton').style.display = 'none'
      document.getElementById('saucerHealthContainer').style.display = 'none'

      // Initialize game function - Make it async to use await
      async function initializeGame() {
        // Clear any existing intervals first
        if (gameIntervals) {
          for (let interval in gameIntervals) {
            clearInterval(gameIntervals[interval])
          }
        }
        console.log('intervals Cleared')

        // Responsive sizing constants (initial call)
        // setCharacterSizes();

        // Show game elements early
        document.getElementById('score').style.display = 'block'
        document.getElementById('player').style.display = 'block'
        document.getElementById('pauseButton').style.display = 'block'
        document.getElementById('saucerHealthContainer').style.display = 'block'

        // Hide start screen
        document.getElementById('startGameContainer').style.display = 'none'

        // Start background music
        startBackgroundMusic()

        // Initialize game state
        isGamePaused = false

        // Reset player position (using potentially inaccurate initial sizes - negligible effect)
        playerX = window.innerWidth / 2
        // Initial bottom guess (will be corrected after fonts load)
        let initialPlayerBottom = window.innerHeight * 0.04 // Simple guess
        player.style.left = `${playerX}px`
        player.style.bottom = `${initialPlayerBottom}px`

        // Add flowers if level 1
        if (gameLevel === 1) {
          addFlowers()
        }

        // --- Wait for fonts to load before final sizing and drawing ---
        try {
          await document.fonts.ready
          console.log('Fonts loaded, proceeding with final layout.')
        } catch (error) {
          console.error('Font loading error or timeout:', error)
        }
        // -------------------------------------------------------------

        // Calculate final sizes ONCE *after* fonts are ready
        setCharacterSizes()

        // Update player position AGAIN with accurate sizes
        playerX = WINDOW_WIDTH / 2 // Recenter based on final width
        player.style.left = `${playerX}px`
        // Set bottom edge of player to align exactly with gameAreaBottom
        player.style.bottom = `${WINDOW_HEIGHT - gameAreaBottom}px`

        // Draw the borders using final dimensions
        draw()

        // Create saucer and ball using final dimensions
        createSaucer()
        document.getElementById('Saucer').style.display = 'block'
        createBall()

        // Start game intervals with fresh set
        gameIntervals = {
          createBall: setInterval(() => {
            // As levels progress, increase chance of creating armored balls
            const armoredChance = Math.min(0.3, 0.05 + (gameLevel - 1) * 0.05) // Up to 30% max

            if (Math.random() < armoredChance && gameLevel > 1) {
              createBall('random', 'armored')
            } else {
              createBall('random', 'standard')
            }
          }, createAlienInterval),
          moveBalls: setInterval(moveBalls, 20),
          moveSaucer: setInterval(moveSaucer, 20),
          updatePlayer: setInterval(updatePlayer, 10),
          moveLasers: setInterval(moveLasers, 15),
          createBonus: setInterval(createBonus, 5000), // Create a bonus every 5 seconds
          moveBonuses: setInterval(moveBonuses, 20), // Move bonuses at same rate as balls
          moveBees: setInterval(moveBees, 25), // Move bees
          moveRockets: setInterval(moveRockets, 20), // <<< ADDED: Move rockets interval
        }
        console.log('gameIntervals ReCreated')
        console.log(balls.length)

        levelMessageContainer = document.getElementById('levelMessageContainer')
        beehiveIconElement = document.getElementById('beehiveDefenseIcon') // Cache icon
        scoreElement = document.getElementById('score')

        // Initialize the beehive icon directly here
        if (beehiveIconElement) {
          console.log(
            'Found beehiveIconElement during initialization.',
            beehiveIconElement,
          )
          beehiveIconElement.innerHTML = '&#x1F41D;' // Bee emoji
          // REMOVED: beehiveIconElement.addEventListener('click', launchBeeSwarm);
          // console.log("Listener ADDED to beehiveIconElement."); // Log no longer accurate
        } else {
          console.error(
            'FAILED to find beehiveIconElement during initialization.',
          )
        }
      }

      // Add start button listener
      document
        .getElementById('startGameButton')
        .addEventListener('click', initializeGame)
      
    function clearAllExistingGameObjects() {
         // Clear existing balls
         while (balls.length > 0) {
          const ball = balls.pop()
          ball.destroy()
        }

        // Clear existing lasers
        while (lasers.length > 0) {
          const laser = lasers.pop()
          laser.destroy()
        }

        // Clear existing bonuses
        while (bonuses.length > 0) {
          const bonus = bonuses.pop()
          bonus.destroy()
        }

        // Clear any existing bees & reset beehive
        while (bees.length > 0) {
          const bee = bees.pop()
          bee.destroy()
        }
        beehiveReady = true // Reset readiness
        if (beehiveIconElement) {
          beehiveIconElement.classList.remove('cooldown') // Remove cooldown style
          beehiveIconElement.innerHTML = '&#x1F41D;' // Ensure bee icon
        }

        // Clear active rockets & reset count
        while (activeRockets.length > 0) {
          const rocket = activeRockets.pop()
          rocket.destroy()
        }
      }
      // Modify restart game function to use initialization
      function restartGame() {
        // Hide game over screen if it's showing
        document.getElementById('gameOverContainer').style.display = 'none'

        // Always reset gameLevel to 1 when restarting
        gameLevel = 1

        // Always reset score when restarting 
        score = 0
        document.getElementById('score').innerHTML = '0'
        document.getElementById('score').style.display = 'block'

        clearAllExistingGameObjects() 

        rocketsRemaining = rocketsPerLevel
        tripleLasersRemaining = tripleLasersPerLevel
        if (rocketCountElement)
          rocketCountElement.textContent = rocketsRemaining.toString()
        if (tripleLaserCountElement)
          tripleLaserCountElement.textContent = tripleLasersRemaining.toString()
        // Reset and recreate saucer
        const oldSaucer = saucers.pop()
        if (oldSaucer && oldSaucer.element) {
          oldSaucer.element.remove()
        }

       
        // Clear existing flowers
        const flowers = document.getElementsByClassName('static-flower')
        while (flowers.length > 0) {
        flowers[0].remove()
        }
        addFlowers()
        // Initialize fresh game
        console.log('Game Restarted with score reset to: ' + score)
        initializeGame()
      }

      // Update element sizes
      document.getElementById('player').style.fontSize = `${PLAYER_SIZE}px`
      document.getElementById('Saucer').style.fontSize = `${ALIEN_SIZE}px`
      document.getElementById('score').style.fontSize =
        `${Math.min(WINDOW_WIDTH, WINDOW_HEIGHT) * 0.1}px`
      document.getElementById('score').style.top = '3px'

      // Initialize canvas
      const canvas = document.querySelector('#canvas')
      // canvas.width = WINDOW_WIDTH; // Initial width setting might be redundant now
      // canvas.height = WINDOW_HEIGHT; // Initial height setting might be redundant now

      // Add game state variable
      let isGamePaused = false

      // Game configuration constants
      const cMAXBALLS = 10
      const cPARTICLES = false
      const LASER_HITBOX_WIDTH = 25 // Width of laser collision detection in pixels
      let score = 0 // Game score - global variable

      const LASER_SOUND = new Audio('sounds/laser_fire.mp3')
      const SPACESHIP_HIT_SOUND = new Audio('sounds/spaceship_hit.mp3')
      const FLOWER_HIT_SOUND = new Audio('sounds/flower_hit.mp3')
      const BACKGROUND_MUSIC = new Audio(
        'sounds/space-ranger-moire-main-version-03-04-10814.mp3',
      )
      const ARMORED_HIT_SOUND = new Audio('sounds/armored_hit.mp3')
      const ARMORED_DEFEAT_SOUND = new Audio('sounds/armored_defeat.mp3')
      const BEE_LAUNCH_SOUND = new Audio('sounds/bees.mp3')
      const ROCKET_LAUNCH_SOUND = new Audio('sounds/rocket.mp3')

      // Set volume levels
      BACKGROUND_MUSIC.volume = 0.5 // Background music at 30% volume
      LASER_SOUND.volume = 0.7 // Sound effects at 70% volume
      SPACESHIP_HIT_SOUND.volume = 0.7
      FLOWER_HIT_SOUND.volume = 0.7

      BACKGROUND_MUSIC.loop = true // Make the music loop continuously

      // Function to handle background music
      function startBackgroundMusic() {
        BACKGROUND_MUSIC.currentTime = 0 // Reset to start
        BACKGROUND_MUSIC.play()
      }

      function addFlowers() {
        const flowerHeightEstimate = BALL_SIZE * 0.8 // Estimate flower height
        const verticalGap = 10 // Gap between rows
        const bottomRowBottomPosition = BORDER_MARGIN + verticalGap // Position first row near bottom border
        const secondRowBottomPosition =
          bottomRowBottomPosition + flowerHeightEstimate + verticalGap // Position second row above first

        // --- First (Lowest) Row of Flowers (5 total) ---
        const bottomPositions = [-110, -62, -14, 35, 88] // Horizontal offsets from center
        var bottomFlowerNum = 0

        bottomPositions.forEach((pos) => {
          bottomFlowerNum += 1
          const flower = document.createElement('div')
          flower.className = 'static-flower bottom-flower' // Keep static-flower class
          flower.style.left = `calc(50% + ${pos}px)`
          flower.style.bottom = `${bottomRowBottomPosition}px` // Explicitly set bottom position
          flower.style.setProperty('--pulse-delay', `${bottomFlowerNum * 0.3}s`)

          if (bottomFlowerNum % 2 === 0) {
            flower.innerHTML = '&#x1F33A;' // Hibiscus
          } else {
            flower.innerHTML = '&#x1F337;' // Tulip
          }

          document.body.appendChild(flower)
        })

        // --- Second Row of Flowers (Above First Row, 5 total) ---
        const secondRowCount = 5
        const gapWidth = gapEndX - gapStartX
        const horizontalSpacing = gapWidth / (secondRowCount + 1) // Divide gap width for spacing
        var secondRowFlowerNum = 0

        for (let i = 1; i <= secondRowCount; i++) {
          secondRowFlowerNum += 1
          const flower = document.createElement('div')
          flower.className = 'static-flower second-row-flower' // Keep static-flower, add specific class
          const flowerX = gapStartX + horizontalSpacing * i // Position relative to gap start
          flower.style.left = `${flowerX}px`
          flower.style.bottom = `${secondRowBottomPosition}px` // Position above the first row
          flower.style.setProperty(
            '--pulse-delay',
            `${(bottomFlowerNum + secondRowFlowerNum) * 0.2}s`,
          ) // Vary delay

          if (secondRowFlowerNum % 2 === 0) {
            flower.innerHTML = '&#x1F33B;' // Sunflower
          } else {
            flower.innerHTML = '&#x1F33C;' // Blossom
          }

          document.body.appendChild(flower)
        }
      }
      function draw() {
        const canvas = document.querySelector('#canvas')
        if (!canvas.getContext) {
          return
        }
        const ctx = canvas.getContext('2d')

        // --- Keep Canvas Clearing (for background/particles) ---
        ctx.fillStyle = 'black'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        // --- End of Clearing ---

        // --- REMOVED ALL ctx.stroke() and OVERLAY CREATION ---
        // The border visuals are now handled by HTML/CSS
        // --- END OF REMOVALS ---
      }

      function draw() {
        const canvas = document.querySelector('#canvas')
        if (!canvas.getContext) {
          return
        }
        const ctx = canvas.getContext('2d')

        // --- Keep Canvas Clearing (for background/particles) ---
        ctx.fillStyle = 'black'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        // --- End of Clearing ---

        // --- REMOVED ALL ctx.stroke() and OVERLAY CREATION ---
        // The border visuals are now handled by HTML/CSS
        // --- END OF REMOVALS ---
      }

      // ****** Bee Class (For the Beehive Defense) *********

      const balls = []
      const lasers = []
      const saucers = []
      const bonuses = [] // Array to hold active bonus boxes
      const bees = []
      const activeRockets = [] // <<< ADDED: Array for active rockets

      function createSaucer() {
        // Place saucer relative to game area boundaries
        const x = gameAreaLeft + (gameAreaRight - gameAreaLeft) / 3
        const y = gameAreaTop - ALIEN_SIZE / 2
        // Use min dimension for speed scaling
        const levelMultiplier = 1 + (gameLevel - 1) * 0.15  // Same scaling as balls
        const baseSpeed = 5 * (Math.min(GAME_WIDTH, GAME_HEIGHT) / 1500) * levelMultiplier
        const saucer = new Saucer(ALIEN_SIZE, getRandomColor(), x, y, baseSpeed)
        saucer.create()
        saucers.push(saucer)
      }

      function calculateAngleToTarget(startX, startY, targetX, targetY) {
        const dx = targetX - startX
        const dy = targetY - startY
        let angle = (Math.atan2(dy, dx) * 180) / Math.PI
        return angle
      }

      function calculateBankShot(startX, startY, targetX, targetY) {
        const useLeftWall = Math.random() < 0.5
        // Use game area boundaries for wall X
        const wallX = useLeftWall ? gameAreaLeft : gameAreaRight

        const dx = targetX - wallX
        const dy = targetY - startY
        const wallY = startY + dy / 2

        // Use game area boundaries for wall Y clamping
        const minWallY = gameAreaTop
        const maxWallY = gameAreaBottom
        const clampedWallY = Math.max(minWallY, Math.min(maxWallY, wallY))

        const angleToWall = calculateAngleToTarget(
          startX,
          startY,
          wallX,
          clampedWallY,
        )
        return angleToWall
      }
      function getArmoredAlienChance() {
        return Math.min(0.6, 0.2 + (gameLevel - 1) * 0.05) // 20% at level 1, increases by 5% per level
      }
      function createBall(shotType = 'random', ballType = 'standard') {
        // Level 1 - 10 ball max, Level 2 : 14 ball max, level 3 :
        if (balls.length > cMAXBALLS + (gameLevel - 1) * (2 * gameLevel)) {
          console.log('Ball Count=' + balls.length)
          return
        }

        // Position ball start relative to saucer center and game area top
        const saucer = saucers[0] // Get saucer reference
        if (!saucer) return // Don't create if saucer doesn't exist

        const saucerCenterX = saucer.x + saucer.size / 2
        const saucerCenterY = saucer.y + saucer.size / 2 // <<< USE CURRENT ALIEN Y
        const x = saucerCenterX
        const y = saucerCenterY
        // Use min dimension for speed scaling
        const speed = 5 * (Math.min(GAME_WIDTH, GAME_HEIGHT) / 1500)

        // Get flower positions
        const flowers = document.getElementsByClassName('static-flower')
        if (flowers.length > 0) {
          // Randomly select a flower to target
          const targetIndex = Math.floor(Math.random() * flowers.length)
          const flowerRect = flowers[targetIndex].getBoundingClientRect()
          const targetX = flowerRect.left + flowerRect.width / 2
          const targetY = flowerRect.top + flowerRect.height / 2

          let angle
          // Determine shot type based on parameter

          if (shotType === 'random') {
            // 50% chance for direct shot vs bank shot
            shotType = Math.random() < DIRECT_HIT_PERCENTAGE ? 'direct' : 'bank'
          }

          if (shotType === 'direct') {
            angle = calculateAngleToTarget(x, y, targetX, targetY)
          } else {
            // shotType === 'bank'
            angle = calculateBankShot(x, y, targetX, targetY)
          }

          // If ballType is 'random', decide which type to create
          if (ballType === 'random') {
            // The higher the level, the more likely we are to get armored balls
            const armoredChance = getArmoredAlienChance() 
            ballType = Math.random() < armoredChance ? 'armored' : 'standard'
          }

          // Create ball with calculated angle and specified type
          const ball = new Ball(
            BALL_SIZE,
            getRandomColor(),
            x,
            y,
            speed,
            angle,
            ballType,
          )
          ball.create('')
          balls.push(ball)
        }
      }

      function getRandomColor() {
        const letters = '0123456789ABCDEF'
        let color = '#'
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)]
        }
        return color
      }

      function moveSaucer() {
        if (isGamePaused) return
        saucers[0].move()
      }

      function moveBalls() {
        for (let i = 0; i < balls.length; i++) {
          balls[i].move()
        }
      }

      // Player movement
      const player = document.getElementById('player')
      let playerX = WINDOW_WIDTH / 2
      player.style.bottom = `${BORDER_MARGIN + BOTTOM_BORDER_OFFSET - 25}px`
      player.style.left = `${playerX}px`
      let isMovingLeft = false
      let isMovingRight = false
      // New variables for smoother movement
      let playerSpeed = 0
      const MAX_PLAYER_SPEED = 8
      const ACCELERATION = 0.5
      const DECELERATION = 0.8

      // Define the named function
      function handleKeyDown(event) {
        console.log('Key Down:', event.key) // <<< ADD LOG TO SEE KEY
        if (event.key === 'ArrowLeft') {
          isMovingLeft = true
        } else if (event.key === 'ArrowRight') {
          isMovingRight = true
        } else if (event.key === '1') {
          // <<< ADDED: Check for '1' key
          launchBeeSwarm() // Launch bees
        } else if (event.key === 'Control') {
          // <<< ADDED: Check for 'Control' key
          event.preventDefault() // Prevent browser default Ctrl actions
          fireRocket() // Launch rocket
        } else if (event.key === 'z') {
          event.preventDefault() // Prevent browser default Ctrl actions
          fireTripleLaser() // Launch triple Laser Beam
        }
      }

      document.addEventListener('keydown', handleKeyDown)

      document.addEventListener('keyup', function (event) {
        if (event.key === 'ArrowLeft') {
          isMovingLeft = false
        } else if (event.key === 'ArrowRight') {
          isMovingRight = false
        }
      })

      function updatePlayer() {
        if (isGamePaused) return

        // Apply acceleration/deceleration for smoother movement
        if (isMovingLeft && !isMovingRight) {
          playerSpeed = Math.max(-MAX_PLAYER_SPEED, playerSpeed - ACCELERATION)
        } else if (isMovingRight && !isMovingLeft) {
          playerSpeed = Math.min(MAX_PLAYER_SPEED, playerSpeed + ACCELERATION)
        } else {
          if (playerSpeed > 0) {
            playerSpeed *= DECELERATION
            if (playerSpeed < 0.1) playerSpeed = 0
          } else if (playerSpeed < 0) {
            playerSpeed *= DECELERATION
            if (playerSpeed > -0.1) playerSpeed = 0
          }
        }

        // Apply player speed
        playerX += playerSpeed

        // Player visual width calculation
        const playerVisualWidth = PLAYER_SIZE * 0.6
        const playerVisualOffset = playerVisualWidth / 2

        // Constrain player horizontal movement
        playerX = Math.max(
          gameAreaLeft + playerVisualOffset,
          Math.min(playerX, gameAreaRight - playerVisualOffset),
        )

        // Update player style
        player.style.left = playerX + 'px'
        // Keep bottom position fixed relative to gameAreaBottom
        // No need to update bottom every frame unless it changes dynamically
        // player.style.bottom = `${WINDOW_HEIGHT - gameAreaBottom + 10}px`; // Usually set only once
      }

      // Window resize handling
      window.addEventListener('resize', function () {
        setCharacterSizes()

        // Update canvas size
        canvas.width = WINDOW_WIDTH
        canvas.height = WINDOW_HEIGHT

        // Update element sizes
        document.getElementById('player').style.fontSize = `${PLAYER_SIZE}px`
        document.getElementById('Saucer').style.fontSize = `${ALIEN_SIZE}px`
        document.getElementById('score').style.fontSize =
          `${Math.min(WINDOW_WIDTH, WINDOW_HEIGHT) * 0.08}px`
        document.getElementById('score').style.top = '30px'

        // Redraw border
        draw()
      })

      // Laser firing
      cMAX_LASERS_AT_ONCE = 5
      cMAX_TRIPLE_LASERS_AT_ONCE = 20

      document.addEventListener('keydown', function (event) {
        if (event.key === ' ' && !isGamePaused) {
          if (lasers.length < cMAX_LASERS_AT_ONCE) {
            // Position laser start at the player's current visual center
            const playerRect = player.getBoundingClientRect() // Get player position
            const laserStartX = playerRect.left + playerRect.width / 2 // Horizontal center
            const laserStartY = playerRect.top // Start at the visual top of the player

            const laser = new Laser(laserStartX, laserStartY)
            laser.create()
            lasers.push(laser)

            LASER_SOUND.currentTime = 0
            LASER_SOUND.play()

            // Energy effect at bottom when firing
            const xPosition = playerX / WINDOW_WIDTH

            applyBorderEffect('border-bottom-left', 'energy', 500) // Target DIV ID
            applyBorderEffect('border-bottom-right', 'energy', 500) // Target DIV ID
          }
        }
      })

      // Separate laser movement and collision detection into its own function
      function moveLasers() {
        if (isGamePaused) return

        for (let i = 0; i < lasers.length; i++) {
          const laser = lasers[i]
          laser.move()

          // Define laser tip coordinates for clarity
          const laserTipX = laser.x
          const laserTipY = laser.y

          // Check for saucer collision (Point-in-Rect check)
          if (saucers.length > 0 && !saucers[0].isDefeated) {
            const saucer = saucers[0]
            // Check if laser tip is within the saucer's bounding box
            // Note: Saucer position (saucer.x, saucer.y) is top-left.
            // Saucer size is saucer.size.
            if (
              laserTipX >= saucer.x &&
              laserTipX <= saucer.x + saucer.size &&
              laserTipY >= saucer.y &&
              laserTipY <= saucer.y + saucer.size
            ) {
              laser.destroy()
              lasers.splice(i, 1)
              i-- // Adjust index after removal

              // ... (ball creation logic remains the same) ...
              const armoredChance = getArmoredAlienChance()

              if (Math.random() < armoredChance) {
                createBall('bank', 'armored') // Bank shot
                createBall('direct', 'armored') // Direct shot
              } else {
                createBall('bank', 'standard') // Bank shot
                createBall('direct', 'standard') // Direct shot
              }

              saucer.takeDamage(4) // Decrease saucer health

              //applyBorderEffect('border-top', 'flash'); // Use new border div if needed

              score += 5

              SPACESHIP_HIT_SOUND.currentTime = 0
              SPACESHIP_HIT_SOUND.play()

              // applyBorderEffect('topBorderOverlay', 'particles', 2000);

              document.getElementById('score').innerHTML = score.toString()
              saucer.flash()
              continue // Skip ball collision check for this laser
            }
          }

          // Check for laser / ball collisions
          // Ball.isColliding uses center-to-center distance, which is correct.
          // We pass the laser tip (x, y) and a small radius/hitbox size.
          // Ensure index `i` is still valid after potential saucer hit removal
          if (i < 0 || i >= lasers.length) continue

          for (let j = 0; j < balls.length; j++) {
            const ball = balls[j]
            // Pass laserTipX, laserTipY which represent the laser's top-center point
            if (ball.isColliding(laserTipX, laserTipY, LASER_HITBOX_WIDTH)) {
              const isDestroyed = ball.takeDamage()

              laser.destroy()
              lasers.splice(i, 1)
              i-- // Adjust index after removing laser

              if (isDestroyed) {
                ball.createExplosion()
                ball.destroy()
                balls.splice(j, 1)
                j-- // Adjust index after removing ball

                if (ball.type === 'armored') {
                  score += 3
                  // Optional: applyBorderEffect('border-top', 'particles', 1000);
                  ARMORED_DEFEAT_SOUND.currentTime = 0
                  ARMORED_DEFEAT_SOUND.play()
                } else {
                  score += 1
                }
              } else {
                // Optional: applyBorderEffect('border-right', 'glow', 500);
                ARMORED_HIT_SOUND.currentTime = 0
                ARMORED_HIT_SOUND.play()
              }

              document.getElementById('score').innerHTML = score.toString()
              break // Laser hit a ball, move to next laser
            }
          }

          // Check for laser / bonus collisions
          // Ensure laser index `i` is still valid after potential saucer/ball hit removal
          if (i < 0 || i >= lasers.length) continue

          for (let k = bonuses.length - 1; k >= 0; k--) {
            const bonus = bonuses[k]
            if (!bonus || !bonus.element) continue // Skip if bonus already destroyed

            // Simple bounding box check: laser tip vs bonus box
            const bonusRect = bonus.element.getBoundingClientRect()
            // Use laserTipX, laserTipY which are the top-center of the laser beam
            if (
              laserTipX >= bonusRect.left &&
              laserTipX <= bonusRect.right &&
              laserTipY >= bonusRect.top &&
              laserTipY <= bonusRect.bottom
            ) {
              bonus.hit() // Handle bonus collection (awards points, plays sound, removes bonus from array)
              // bonuses.splice(k, 1); // Removal is now handled inside bonus.hit()

              laser.destroy() // Destroy the laser
              lasers.splice(i, 1) // Remove laser from array
              i-- // Adjust laser index

              // TODO: Play bonus collect sound here? (Or confirm it's in bonus.hit())

              break // Laser hit a bonus, move to next laser
            }
          }

          // Remove lasers that go off screen (using gameAreaTop)
          // Ensure index `i` is still valid after potential ball/bonus hit removal
          if (i >= 0 && i < lasers.length && laserTipY <= gameAreaTop) {
            laser.destroy()
            lasers.splice(i, 1)
            i-- // Adjust index after removal
          }
        }
      }

      // ******* end of Laser Movement and Collision **************
      const CANVAS = document.getElementsByTagName('canvas')[0],
        CTX = CANVAS.getContext('2d'),
        W = GAME_WIDTH,
        H = GAME_HEIGHT,
        XO = W / 2 + BORDER_MARGIN,
        YO = H / 2 + BORDER_MARGIN,
        PARTICLES = []

      // Call once on page load to start the animation
      init()

      function init() {
        // Initial canvas setup - Use current window dimensions directly
        CANVAS.width = window.innerWidth
        CANVAS.height = window.innerHeight

        // We will calculate final sizes later in initializeGame after fonts load
        // setCharacterSizes(); // Remove this initial call

        // Create particles if enabled (might need adjustment if dependent on precise sizes)
        if (cPARTICLES) {
          // If particle creation relies heavily on BORDER_MARGIN etc,
          // it might need to move into the initializeGame async block too.
          // For now, assume it's okay here.
          createParticles()
          loop()
        }

        // Do not draw initially here, wait for initializeGame
        // draw();
      }

      function loop() {
        requestAnimationFrame(loop)

        CTX.save()

        // Clip to exact inner border boundaries, accounting for bottom border
        CTX.beginPath()
        CTX.rect(
          BORDER_MARGIN + BORDER_OFFSET,
          BORDER_MARGIN + BORDER_OFFSET,
          GAME_WIDTH - 2 * BORDER_OFFSET, // Adjusted width to not overlap borders
          GAME_HEIGHT -
            2 * BORDER_OFFSET -
            (BOTTOM_BORDER_WIDTH - BORDER_WIDTH),
        )
        CTX.clip()

        // Clear previous frame completely
        CTX.clearRect(
          BORDER_MARGIN + BORDER_OFFSET,
          BORDER_MARGIN + BORDER_OFFSET,
          GAME_WIDTH - 2 * BORDER_OFFSET,
          GAME_HEIGHT -
            2 * BORDER_OFFSET -
            (BOTTOM_BORDER_WIDTH - BORDER_WIDTH),
        )

        // Background for depth (completely black)
        CTX.fillStyle = 'rgba(0,0,0,1)'
        CTX.fillRect(
          BORDER_MARGIN + BORDER_OFFSET,
          BORDER_MARGIN + BORDER_OFFSET,
          GAME_WIDTH - 2 * BORDER_OFFSET,
          GAME_HEIGHT -
            2 * BORDER_OFFSET -
            (BOTTOM_BORDER_WIDTH - BORDER_WIDTH),
        )

        // Always render particles
        render()

        CTX.restore()
      }

      function createParticles() {
        PARTICLES.length = 0 // Clear any existing particles
        // Create a lot more particles for a denser star field
        const particleCount = Math.floor((WINDOW_WIDTH * WINDOW_HEIGHT) / 2000)
        for (let i = 0; i < particleCount; i++) {
          PARTICLES.push(new Particle())
        }
      }

      // Add pause button functionality
      const pauseButton = document.getElementById('pauseButton')
      pauseButton.style.bottom = `${BORDER_MARGIN + BORDER_OFFSET - 50}px`

      // Add unified pause/unpause functions
      function pauseGame(playerPaused = false) {
        isGamePaused = true
        pauseButton.textContent = '‚ñ∂Ô∏è' // Play symbol
        document.body.classList.add('game-paused') // Add class to body

        // Clear all intervals
        if (gameIntervals) {
          for (let interval in gameIntervals) {
            clearInterval(gameIntervals[interval])
            gameIntervals[interval] = null // Set to null to ensure GC
          }
          // Explicitly clear potential lingering references if object wasn't fully cleared
          gameIntervals.createBall = null
          gameIntervals.moveBalls = null
          gameIntervals.moveSaucer = null
          gameIntervals.updatePlayer = null
          gameIntervals.moveLasers = null
          gameIntervals.createBonus = null
          gameIntervals.moveBonuses = null
          gameIntervals.moveBees = null // Clear bee interval
          gameIntervals.moveRockets = null // <<< ADDED: Clear rocket interval
        }

        if (playerPaused) {
          BACKGROUND_MUSIC.pause() // Pause the music
        }
      }
      function unpauseGame() {
        // Always make sure to clear any existing intervals first
        if (gameIntervals) {
          for (let interval in gameIntervals) {
            clearInterval(gameIntervals[interval])
            gameIntervals[interval] = null
          }
        }

        isGamePaused = false
        pauseButton.textContent = '‚è∏Ô∏è' // Pause symbol
        document.body.classList.remove('game-paused') // Remove class from body

        // Restart all game intervals with adjusted speeds
        gameIntervals = {
          createBall: setInterval(createBall, createAlienInterval),
          moveBalls: setInterval(moveBalls, 20),
          moveSaucer: setInterval(moveSaucer, 20),
          updatePlayer: setInterval(updatePlayer, 10),
          moveLasers: setInterval(moveLasers, 15),
          createBonus: setInterval(createBonus, 5000), // Create a bonus every 5 seconds
          moveBonuses: setInterval(moveBonuses, 20), // Move bonuses at same rate as balls
          moveBees: setInterval(moveBees, 25), // Restart bee interval
          moveRockets: setInterval(moveRockets, 20), // <<< ADDED: Restart rocket interval
        }

        BACKGROUND_MUSIC.play() // Resume the music
      }
      function levelUp() {
        // Always make sure to clear any existing intervals first
        gameLevel++

        // Stop Animations. 
        if (gameIntervals) {
          for (let interval in gameIntervals) {
            clearInterval(gameIntervals[interval])
            gameIntervals[interval] = null
          }
        }
        clearAllExistingGameObjects
       
        // Get updated speed values based on current level
        const baseSpeed = 5 * (GAME_WIDTH / 1500)
        const saucerSpeed = baseSpeed * (1 + (gameLevel - 1) * 0.2) // Increase saucer speed by 20% per level
        const ballSpeed = baseSpeed * (1 + (gameLevel - 1) * 0.15) // Increase ball speed by 15% per level

        // Create the saucer for the current level if it doesn't exist
        if (saucers.length === 0) {
          // Create a new saucer with updated speed
          createSaucer()
          document.getElementById('saucerHealthContainer').style.display =
            'block'
        } else {
          // Reposition existing saucer to center of screen
          const centerX = GAME_WIDTH / 2 - saucers[0].size / 2 + BORDER_MARGIN
          saucers[0].x = centerX
          saucers[0].element.style.left = centerX + 'px'
          saucers[0].element.style.top = BORDER_MARGIN + BORDER_OFFSET + 'px'

          // Reset saucer classes to remove defeat animation if present
          saucers[0].element.className = 'saucer'

          saucers[0].y = saucers[0].initialY
          saucers[0].isBerserk = false

          // Reset health
          saucers[0].initialHealth = cTEST_MODE ? 20 : (140 + (SAUCER_HEALTH_INCREASE * gameLevel))
          saucers[0].health = saucers[0].initialHealth
          
          document.getElementById('saucerHealthBar').style.width = '100%'
          document.getElementById('saucerHealthContainer').style.display =
            'block'
        }
        createAlienInterval = createAlienInterval * ALIEN_CREATION_INTERVAL_DECREASE
        if (createAlienInterval < MIN_ALIEN_CREATION_INTERVAL) {createAlienInterval === MIN_ALIEN_CREATION_INTERVAL}
        
        // Game was paused to show level info /Level Up message , Unpause it now
        isGamePaused = false
        pauseButton.textContent = '‚è∏Ô∏è' // Pause symbol

        // Restart all game intervals with adjusted speeds
        gameIntervals = {
          createBall: setInterval(() => {
            // As levels progress, increase chance of creating armored balls
            const armoredChance = getArmoredAlienChance()

            if (Math.random() < armoredChance && gameLevel > 1) {
              createBall('random', 'armored')
            } else {
              createBall('random', 'standard')
            }
          }, createAlienInterval),
          moveBalls: setInterval(moveBalls, 20),
          moveSaucer: setInterval(moveSaucer, 20),
          updatePlayer: setInterval(updatePlayer, 10),
          moveLasers: setInterval(moveLasers, 15),
          createBonus: setInterval(createBonus, 5000), // Create a bonus every 5 seconds
          moveBonuses: setInterval(moveBonuses, 20), // Move bonuses at same rate as balls
          moveBees: setInterval(moveBees, 25), // Restart bee interval
          moveRockets: setInterval(moveRockets, 20), // <<< ADDED: Restart rocket interval
        }

        BACKGROUND_MUSIC.play() // Resume the music
        rocketsRemaining = rocketsPerLevel
        tripleLasersRemaining = tripleLasersPerLevel
        if (tripleLaserCountElement)
          tripleLaserCountElement.textContent = tripleLasersRemaining.toString()
      }

      pauseButton.addEventListener('click', function (event) {
        // Only toggle pause state if it's an actual mouse click
        if (event.isTrusted && event.type === 'click') {
          if (isGamePaused) {
            unpauseGame()
          } else {
            pauseGame(true)
          }
        }
      })

      // Prevent spacebar from activating the pause button when mouse is over it
      pauseButton.addEventListener('keydown', function (event) {
        if (event.key === ' ' || event.code === 'Space') {
          event.preventDefault()
          return false
        }
      })

      // Add a keyboard shortcut for pause that won't interfere with the button
      document.addEventListener('keydown', function (event) {
        if (event.key === 'p' || event.key === 'P') {
          if (isGamePaused) {
            unpauseGame()
          } else {
            pauseGame(true)
          }
        }
      })

      // Modify movement functions to respect pause state
      function moveBalls() {
        if (isGamePaused) return
        for (let i = 0; i < balls.length; i++) {
          balls[i].move()
        }
      }

      function moveSaucer() {
        if (isGamePaused) return
        saucers[0].move()
      }

      function updatePlayer() {
        if (isGamePaused) return

        // Apply acceleration/deceleration for smoother movement
        if (isMovingLeft && !isMovingRight) {
          playerSpeed = Math.max(-MAX_PLAYER_SPEED, playerSpeed - ACCELERATION)
        } else if (isMovingRight && !isMovingLeft) {
          playerSpeed = Math.min(MAX_PLAYER_SPEED, playerSpeed + ACCELERATION)
        } else {
          if (playerSpeed > 0) {
            playerSpeed *= DECELERATION
            if (playerSpeed < 0.1) playerSpeed = 0
          } else if (playerSpeed < 0) {
            playerSpeed *= DECELERATION
            if (playerSpeed > -0.1) playerSpeed = 0
          }
        }

        // Apply player speed
        playerX += playerSpeed

        // Player visual width calculation
        const playerVisualWidth = PLAYER_SIZE * 0.6
        const playerVisualOffset = playerVisualWidth / 2

        // Constrain player horizontal movement
        playerX = Math.max(
          gameAreaLeft + playerVisualOffset,
          Math.min(playerX, gameAreaRight - playerVisualOffset),
        )

        // Update player style
        player.style.left = playerX + 'px'
        // Keep bottom position fixed relative to gameAreaBottom
        // No need to update bottom every frame unless it changes dynamically
        // player.style.bottom = `${WINDOW_HEIGHT - gameAreaBottom + 10}px`; // Usually set only once
      }

      // Add game over function
      function endGame() {
        isGamePaused = true

        // Clear all intervals
        for (let interval in gameIntervals) {
          clearInterval(gameIntervals[interval])
        }

        // Hide player and saucer
        document.getElementById('player').style.display = 'none'
        if (saucers.length > 0 && saucers[0].element) {
          saucers[0].element.style.display = 'none'
        }

        // Hide health bar
        document.getElementById('saucerHealthContainer').style.display = 'none'

        // Clear any existing lasers
        while (lasers.length > 0) {
          const laser = lasers.pop()
          laser.destroy()
        }

        // Clear any existing balls
        while (balls.length > 0) {
          const ball = balls.pop()
          ball.destroy()
        }

        // Clear any existing bonuses
        while (bonuses.length > 0) {
          const bonus = bonuses.pop()
          bonus.destroy()
        }

        // Clear any existing bees & reset beehive state
        while (bees.length > 0) {
          const bee = bees.pop()
          bee.destroy()
        }
        beehiveReady = true // Reset readiness
        if (beehiveIconElement) {
          beehiveIconElement.classList.remove('cooldown') // Remove cooldown style
          beehiveIconElement.innerHTML = '&#x1F41D;' // Ensure bee icon
        }

        // Clear active rockets
        while (activeRockets.length > 0) {
          const rocket = activeRockets.pop()
          rocket.destroy()
        }
        rocketsRemaining = rocketsPerLevel
        if (rocketCountElement)
          rocketCountElement.textContent = rocketsRemaining.toString()

        BACKGROUND_MUSIC.pause() // Stop the music

        // Show game over screen
        document.getElementById('gameOverContainer').style.display = 'block'
      }

      // Add play again button listener
      document
        .getElementById('playAgainButton')
        .addEventListener('click', restartGame)

      // Add sound effect for flower hits
      function createFlowerDeathAnimation(flower) {
        // Play the hit sound
        FLOWER_HIT_SOUND.currentTime = 0 // Reset sound to start
        FLOWER_HIT_SOUND.play()

        const flowerRect = flower.getBoundingClientRect()
        const flowerX = flowerRect.left + flowerRect.width / 2
        const flowerY = flowerRect.top + flowerRect.height / 2

        // Create container for the petals
        const petalContainer = document.createElement('div')
        petalContainer.style.position = 'absolute'
        petalContainer.style.left = flowerX + 'px'
        petalContainer.style.top = flowerY - 5 + 'px'
        petalContainer.style.zIndex = '1000'

        // Create multiple petals
        const numPetals = 8
        const petalEmojis = ['üå∏', 'üå∫', 'üåπ'] // Petal options

        for (let i = 0; i < numPetals; i++) {
          const petal = document.createElement('div')
          petal.className = 'petal'
          petal.textContent =
            petalEmojis[Math.floor(Math.random() * petalEmojis.length)]

          // Calculate random direction and rotation for each petal
          const angle = (i / numPetals) * 360 + Math.random() * 30
          const distance = 100 + Math.random() * 50
          const tx = Math.cos((angle * Math.PI) / 180) * distance
          const ty = Math.sin((angle * Math.PI) / 180) * distance + 100 // Add extra downward motion
          const rotation = Math.random() * 360

          petal.style.setProperty('--tx', `${tx}px`)
          petal.style.setProperty('--ty', `${ty}px`)
          petal.style.setProperty('--rotation', `${rotation}deg`)

          petalContainer.appendChild(petal)
        }

        document.body.appendChild(petalContainer)

        // Remove container after animation
        setTimeout(() => {
          if (petalContainer.parentNode) {
            petalContainer.parentNode.removeChild(petalContainer)
          }
        }, 1500)
      }

      function init() {
        CANVAS.width = W
        CANVAS.height = H
        if (cPARTICLES) {
          createParticles()
          loop()
        }
      }

      // Only initialize canvas and background particles
      init()

      // Add function to create decorative flowers
      function createDecorativeFlowers() {
        const flowerRow = document.getElementById('decorativeFlowerRow')
        const screenWidth = window.innerWidth
        const flowerWidth = 60 // Approximate width of each flower emoji with spacing
        const numFlowers = 9

        for (let i = 0; i < numFlowers; i++) {
          const flower = document.createElement('span')
          if (i % 2 === 0) {
            flower.innerHTML = '&#x1F337;' // Rose
          } else {
            flower.innerHTML = '&#x1F33A;' // Hibiscus
          }
          flowerRow.appendChild(flower)
        }
      }

      // Call this when the page loads
      createDecorativeFlowers()

      function showLevelComplete() {
        const container = document.getElementById('levelMessageContainer')
        // Clear any existing messages
        container.innerHTML = ''

        // Create a container for the "Level Complete!" message
        const completeMsgContainer = document.createElement('div')
        completeMsgContainer.className = 'message-container'
        container.appendChild(completeMsgContainer)

        // Create and show "Level Complete!" message
        const completeMsg = document.createElement('div')
        completeMsg.className = 'level-message'
        completeMsg.textContent = 'Level Complete!'
        completeMsg.style.animation = 'fadeInOut 2s forwards'
        completeMsgContainer.appendChild(completeMsg)

        // After 2 seconds, show next level message in its own container
        setTimeout(() => {
          // Clear previous messages
          container.innerHTML = ''

          // Create a new container for the next level message
          const nextLevelContainer = document.createElement('div')
          nextLevelContainer.className = 'message-container'
          container.appendChild(nextLevelContainer)

          const nextLevelMsg = document.createElement('div')
          nextLevelMsg.className = 'level-message'
          nextLevelMsg.textContent = `Level ${gameLevel + 1}`
          // Use the fadeInStay animation that remains visible
          nextLevelMsg.style.animation = 'fadeInStay 0.5s forwards'
          nextLevelContainer.appendChild(nextLevelMsg)

          // Remove messages and unpause game
          setTimeout(() => {
            container.innerHTML = ''
            levelUp()
            console.log('Level Up Complete')
          }, 2000)
        }, 2000)
        saucers[0].isDefeated = false
      }

      // Utility function to apply effects to border overlays
      function applyBorderEffect(overlayId, effect, duration = 2000) {
        const overlay = document.getElementById(overlayId)
        if (!overlay) return

        // Reset specific styles potentially used by effects, NOT innerHTML
        overlay.style.transition = ''
        overlay.style.boxShadow = ''
        overlay.style.backgroundImage = '' // Reset background image if used by energy effect
        overlay.style.animation = '' // Reset animation if used
        // Remove any leftover particle elements if that effect was used
        const existingParticles = overlay.querySelectorAll('.border-particle')
        existingParticles.forEach((p) => p.remove())

        // REMOVED: overlay.innerHTML = '';

        switch (effect) {
          case 'flash':
            // Flash effect - brighten the existing background
            const currentBg = window.getComputedStyle(overlay).backgroundColor
            overlay.style.transition = 'background-color 0.2s ease-in-out'
            overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.7)' // Brighter flash
            setTimeout(() => {
              // Restore the original background from CSS
              overlay.style.backgroundColor = ''
            }, 200)
            break

          case 'glow':
            // Glow effect
            overlay.style.transition = 'box-shadow 0.5s ease-in-out'
            overlay.style.boxShadow = 'inset 0 0 20px rgba(255, 215, 0, 0.6)'
            setTimeout(() => {
              overlay.style.boxShadow = ''
            }, duration)
            break

          case 'particles':
            // Particle effect
            const particleCount = Math.floor(
              (overlay.offsetWidth * overlay.offsetHeight) / 5000,
            )
            for (let i = 0; i < particleCount; i++) {
              const particle = document.createElement('div')
              particle.className = 'border-particle'
              particle.style.position = 'absolute'
              particle.style.width = '3px'
              particle.style.height = '3px'
              particle.style.backgroundColor = 'gold'
              particle.style.borderRadius = '50%'
              particle.style.left = `${Math.random() * 100}%`
              particle.style.top = `${Math.random() * 100}%`
              particle.style.opacity = Math.random()
              particle.style.animation = `fadeOut ${Math.random() * 1.5 + 0.5}s linear`
              overlay.appendChild(particle)
            }
            setTimeout(() => {
              const particles = overlay.querySelectorAll('.border-particle')
              particles.forEach((p) => p.remove())
            }, duration)
            break

          case 'warning':
            // Warning effect (red pulsing)
            // overlay.style.animation = 'pulsateRed 0.5s infinite alternate'; // REMOVE old animation
            // Apply a red outer glow instead
            overlay.style.boxShadow = '0 0 25px 10px rgba(255, 0, 0, 0.7)' // Red glow
            overlay.style.transition = 'box-shadow 0.1s ease-in-out' // Add quick transition
            setTimeout(() => {
              // overlay.style.animation = ''; // No longer needed
              overlay.style.boxShadow = '' // Remove the glow
            }, duration)
            break

          case 'energy':
            // Energy charge effect
            // Increased opacity from 0.2 to 0.8 for visibility
            overlay.style.backgroundImage =
              'linear-gradient(to bottom, transparent, rgba(0, 255, 255, 0.8), transparent)'
            overlay.style.backgroundSize = '100% 50px'
            overlay.style.backgroundRepeat = 'repeat-y'
            overlay.style.backgroundPosition = '0 -50px'
            overlay.style.animation = 'energyFlow 1s infinite linear'
            setTimeout(() => {
              overlay.style.backgroundImage = ''
              overlay.style.animation = ''
            }, duration)
            break
        }
      }

      // --- Mouse Boundary Test Function ---
      function handleMouseMove(event) {
        const mouseX = event.clientX
        const mouseY = event.clientY

        let location = 'Outside' // Default

        // 1. Check for main game area (Above the bottom border)
        if (
          mouseX > gameAreaLeft &&
          mouseX < gameAreaRight &&
          mouseY > gameAreaTop &&
          mouseY < gameAreaBottom
        ) {
          location = 'Inside Game Area'
        }
        // 2. Check for bottom gap area (Below main area, within gap X)
        else if (
          mouseY >= gameAreaBottom &&
          mouseX > gapStartX &&
          mouseX < gapEndX
        ) {
          location = 'Inside Bottom Gap'
        }
        // 3. Check Border Regions (only if not in game area or gap)
        else if (
          mouseY <= gameAreaTop &&
          mouseX >= gameAreaLeft &&
          mouseX <= gameAreaRight
        ) {
          location = 'Top Border Area'
        } else if (
          mouseX <= gameAreaLeft &&
          mouseY >= gameAreaTop &&
          mouseY <= gameAreaBottom
        ) {
          location = 'Left Border Area'
        } else if (
          mouseX >= gameAreaRight &&
          mouseY >= gameAreaTop &&
          mouseY <= gameAreaBottom
        ) {
          location = 'Right Border Area'
        }
        // Check bottom left border area
        else if (
          mouseY >= gameAreaBottom &&
          mouseX >= gameAreaLeft &&
          mouseX <= gapStartX
        ) {
          location = 'Bottom Left Border Area'
        }
        // Check bottom right border area
        else if (
          mouseY >= gameAreaBottom &&
          mouseX >= gapEndX &&
          mouseX <= gameAreaRight
        ) {
          location = 'Bottom Right Border Area'
        }

        // Log only if location changes
        if (handleMouseMove.lastLocation !== location) {
          console.log(`Mouse: (${mouseX}, ${mouseY}) - Location: ${location}`)
          handleMouseMove.lastLocation = location
        }
      }
      handleMouseMove.lastLocation = '' // Initialize for change detection

      // Add the event listener
      if (cTEST_MODE) {
        document.addEventListener('mousemove', handleMouseMove)
      }
      // ----------------------------------

      // Function to create a new bonus object
      function createBonus() {
        if (isGamePaused) return // Don't create if paused

        // Limit the number of bonuses on screen at once
        const maxBonuses = 3
        if (bonuses.length >= maxBonuses) {
          return
        }

        // Calculate a random vertical position within the main play area
        // Avoid spawning too close to the top or bottom borders
        const minY = gameAreaTop + BALL_SIZE
        // Restrict maxY to the top 50% of the game area
        const maxY = gameAreaTop + (gameAreaBottom - gameAreaTop) / 2
        const randomY = minY + Math.random() * (maxY - minY)

        const bonus = new Bonus(randomY)
        bonus.create()
        bonuses.push(bonus)
      }

      // Function to move all active bonuses
      function moveBonuses() {
        if (isGamePaused) return
        // Iterate backwards to safely remove items while iterating
        for (let i = bonuses.length - 1; i >= 0; i--) {
          // Ensure the bonus still exists before moving (might have been hit)
          if (bonuses[i]) {
            bonuses[i].move()
          }
          // Note: Off-screen removal is handled within Bonus.move()
        }
      }
      // Function to launch the bee swarm from the icon
      function launchBeeSwarm() {
        console.log('launchBeeSwarm function entered!') // <<< ADD THIS LOG

        const now = Date.now()
        if (!beehiveReady || now < lastBeehiveTime + BEEHIVE_COOLDOWN) {
          console.log('Beehive on cooldown.')
          // Optionally provide visual feedback like a shake
          return
        }

        beehiveReady = false
        lastBeehiveTime = now

        // Update icon visual state
        if (beehiveIconElement) {
          beehiveIconElement.classList.add('cooldown')
          // Change icon during cooldown?
          beehiveIconElement.innerHTML = '‚è≥'
        }

        // --- Start cooldown timer to reset readiness ---
        setTimeout(() => {
          console.log('COOLDOWN TIMER FINISHED: Resetting beehive state.') // <<< ADD LOG
          beehiveReady = true // Set ready again
          if (beehiveIconElement) {
            console.log('Attempting to remove cooldown class and reset icon.') // <<< ADD LOG
            beehiveIconElement.classList.remove('cooldown') // Remove cooldown style
            // Restore icon to Bee, not satellite
            beehiveIconElement.innerHTML = '&#x1F41D;'
          } else {
            console.error('Beehive icon element lost before cooldown finished?') // <<< ADD LOG
          }
          console.log('Beehive ready flag set to true!')
        }, BEEHIVE_COOLDOWN) // Timer runs for 15 seconds
        // ---------------------------------------------

        // --- Create the swarm ---
        if (!beehiveIconElement) {
          console.error('Cannot launch bees: Beehive icon element not cached.')
          return // Can't proceed without the icon element
        }
        const iconRect = beehiveIconElement.getBoundingClientRect()
        const startX = iconRect.left + iconRect.width / 2
        const startY = iconRect.top + iconRect.height / 2

        for (let i = 0; i < BEE_SWARM_SIZE; i++) {
          // Add slight randomness to start position to avoid perfect stack
          const beeStartX = startX + (Math.random() - 0.5) * 10
          const beeStartY = startY + (Math.random() - 0.5) * 10
          console.log(
            `Creating bee ${i} at: X=${beeStartX.toFixed(2)}, Y=${beeStartY.toFixed(2)}`,
          ) // <<< LOG START COORDS
          const bee = new Bee(beeStartX, beeStartY)
          bee.create()
          bees.push(bee)
        }

        BEE_LAUNCH_SOUND.currentTime = 0
        BEE_LAUNCH_SOUND.play()

        console.log(`Launched ${swarmSize} bees.`)
      }

      // Function to move all active bees and check collisions
      function moveBees() {
        // console.log(`moveBees called. Paused=${isGamePaused}, BeeCount=${bees.length}`); // Keep logs minimal now
        if (isGamePaused) return

        // --- Target Acquisition Phase ---
        const availableBalls = balls.filter((ball) => !ball.isTargetedByBee)
        // ONLY consider bees currently in 'seeking' state for new targets
        const seekingBees = bees.filter((bee) => bee.state === 'seeking') // Was potentialSeekers

        let ballIndex = 0
        // Loop through bees that are actually seeking
        for (let bee of seekingBees) {
          // Use seekingBees
          if (
            availableBalls.length === 0 ||
            ballIndex >= availableBalls.length
          ) {
            // No available balls left. Seeking bees will continue idle movement.
            break
          }

          // Assign target
          const target = availableBalls[ballIndex]
          bee.targetBall = target
          bee.state = 'attacking' // Switch state to attacking
          target.isTargetedByBee = true
          console.log(
            `Bee ${bee.element?.id || 'N/A'} assigned to target Ball.`,
          )

          ballIndex++
        }
        // -----------------------------

        // --- Movement & Collision Phase ---
        // Iterate backwards for safe removal during movement/collision checks
        for (let i = bees.length - 1; i >= 0; i--) {
          const bee = bees[i]
          if (!bee) continue

          bee.move() // Bee.move now handles state logic & collisions

          // Check if bee was destroyed during its move() call (e.g., hit target or went off screen)
          if (!bees.includes(bee)) {
            // Bee was destroyed and already removed itself (or should have)
            // Need to ensure it's removed from the main array if destroy didn't
            if (bees[i] === bee) {
              // Check if it wasn't already removed by splice in destroy
              console.warn(
                `Bee was destroyed but maybe not removed from array in destroy? Splicing now.`,
              )
              bees.splice(i, 1)
            }
            continue // Move to the next bee index
          }
        }
        // -------------------------------
      }
      // <<< ADDED: Function to fire a rocket >>>
      function fireRocket() {
        if (isGamePaused || rocketsRemaining <= 0) {
          console.log(
            `Cannot fire rocket. Paused=${isGamePaused}, Remaining=${rocketsRemaining}`,
          )
          // Optional: Add a sound effect for empty/fail?
          return
        }

        rocketsRemaining--
        if (rocketCountElement) {
          rocketCountElement.textContent = rocketsRemaining.toString()
        } else {
          console.warn('rocketCountElement not cached, cannot update display.')
        }
        console.log(`Firing rocket! Remaining: ${rocketsRemaining}`)

        // Position rocket start at the player's current visual center
        const playerRect = player.getBoundingClientRect()
        const rocketStartX = playerRect.left + playerRect.width / 2 // Horizontal center
        const rocketStartY = playerRect.top // Start at the visual top of the player

        const rocket = new Rocket(rocketStartX, rocketStartY)
        rocket.create()
        activeRockets.push(rocket)

        ROCKET_LAUNCH_SOUND.currentTime = 0
        ROCKET_LAUNCH_SOUND.play()
      }
      function fireTripleLaser() {
        if (tripleLasersRemaining > 0) {
          if (lasers.length < cMAX_TRIPLE_LASERS_AT_ONCE) {
            // Position laser start at the player's current visual center
            const playerRect = player.getBoundingClientRect() // Get player position
            const laserStartX = playerRect.left + playerRect.width / 2 // Horizontal center
            const laserStartY = playerRect.top // Start at the visual top of the player

            tripleLasersRemaining--
            LASER_SOUND.currentTime = 0
            LASER_SOUND.play()
            // update Display as tripleLasers remaining is reduced
            if (tripleLaserCountElement) {
              tripleLaserCountElement.textContent =
                tripleLasersRemaining.toString()
            } else {
              console.warn(
                'tripleLaserCountElement not cached, cannot update display.',
              )
            }

            for (let i = 0; i < 3; i++) {
              // Calculate angle: 45¬∞ for first, 90¬∞ for second, 135¬∞ for third
              const angle = 45 + i * 45
              const laser = new Laser(laserStartX, laserStartY, angle)
              laser.create()
              lasers.push(laser)
            }

            // Energy effect at bottom when firing
            //const xPosition = playerX / WINDOW_WIDTH;

            //applyBorderEffect('border-bottom-left', 'energy', 500); // Target DIV ID
            //applyBorderEffect('border-bottom-right', 'energy', 500); // Target DIV ID
          }
        }
      }
      // <<< ADDED: Function to move rockets and check boundaries >>>
      function moveRockets() {
        if (isGamePaused) return

        for (let i = activeRockets.length - 1; i >= 0; i--) {
          const rocket = activeRockets[i]
          rocket.move()

          // Define rocket tip coordinates for collision detection
          const rocketTipX = rocket.x
          const rocketTipY = rocket.y
             // Check for saucer collision (Point-in-Rect check)
        if (saucers.length > 0 && !saucers[0].isDefeated) {
           
            const saucer = saucers[0]
            // Check if Rocket tip is within the saucer's bounding box
            // Note: Saucer position (saucer.x, saucer.y) is top-left.
            // Saucer size is saucer.size.
            if (saucer.isColliding(rocketTipX, rocketTipY, rocket.size)) {
                rocket.destroy()
                activeRockets.splice(i, 1)
                i-- // Adjust index after removal

                saucer.takeDamage(12) // Decrease saucer health
                score += 40
                SPACESHIP_HIT_SOUND.currentTime = 0
                SPACESHIP_HIT_SOUND.play()
                document.getElementById('score').innerHTML = score.toString()
                
                // Only show hit explosion if the saucer isn't defeated
                if (!saucer.isDefeated) {
                    createRocketSaucerHitExplosion(saucer.x + saucer.size/2, saucer.y + saucer.size/2);
                }
                break // Rocket exploded, move to next rocket
            } 
          }
          // Check for rocket / ball collisions
          for (let j = 0; j < balls.length; j++) {
            const ball = balls[j]
            // Pass rocketTipX, rocketTipY which represent the rocket's center point
            // Using same hitbox width as laser for now
            if (ball.isColliding(rocketTipX, rocketTipY, LASER_HITBOX_WIDTH)) {
              // Store the hit ball's position for the explosion
              const explosionX = ball.x
              const explosionY = ball.y

              // Destroy the primary ball that was hit
              ball.createExplosion()
              ball.destroy()
              balls.splice(j, 1)

              // Destroy the rocket
              rocket.destroy()
              activeRockets.splice(i, 1)

              ROCKET_LAUNCH_SOUND.pause() // Pause the sound
              ROCKET_LAUNCH_SOUND.currentTime = 0 // Reset to beginning

              // Calculate the explosion radius (5 ball widths)
              const explosionRadius = BALL_SIZE * 4

              // Create the large visual explosion effect
              createLargeExplosion(explosionX, explosionY, explosionRadius)

              // Area effect: destroy all balls within explosion radius
              for (let k = balls.length - 1; k >= 0; k--) {
                const nearbyBall = balls[k]

                // Calculate distance between explosion center and this ball
                const dx = nearbyBall.x - explosionX
                const dy = nearbyBall.y - explosionY
                const distance = Math.sqrt(dx * dx + dy * dy)

                // If ball is within explosion radius, destroy it regardless of armor
                if (distance <= explosionRadius) {
                  nearbyBall.createExplosion()
                  nearbyBall.destroy()
                  balls.splice(k, 1)

                  // Award points based on ball type
                  if (nearbyBall.type === 'armored') {
                    score += 3
                  } else {
                    score += 1
                  }
                }
              }

              // Play a larger explosion sound
              ARMORED_DEFEAT_SOUND.currentTime = 0
              ARMORED_DEFEAT_SOUND.play()

              // Update score display
              document.getElementById('score').innerHTML = score.toString()
              break // Rocket exploded, move to next rocket
            }
          }
  
          // --- Basic Off-Screen Check (Top) ---
          // Only check if rocket hasn't been destroyed in collision
          if (i >= 0 && i < activeRockets.length) {
            const rocketTopEdge = rocket.y - rocket.size / 2 // Approximate top
            if (rocketTopEdge < gameAreaTop) {
              rocket.destroy()
              activeRockets.splice(i, 1)
              console.log('Rocket removed (off-screen).')
            }
          }
          // --------------------------------------
        }
      }
      rocketCountElement = document.getElementById('rocketCount') // Cache counter span
      tripleLaserCountElement = document.getElementById('tripleLaserCount') // Cache counter span
      // Initialize rocket count
      rocketsRemaining = rocketsPerLevel
      tripleLasersRemaining = tripleLasersPerLevel

      if (rocketCountElement) {
        rocketCountElement.textContent = rocketsRemaining.toString()
      }
      if (tripleLaserCountElement) {
        tripleLaserCountElement.textContent = tripleLasersRemaining.toString()
      }

      // Function to create a large rocket explosion
      function createLargeExplosion(x, y, radius) {
        // Create container for the explosion
        const explosionContainer = document.createElement('div')
        explosionContainer.className = 'rocket-explosion'
        explosionContainer.style.position = 'absolute'
        explosionContainer.style.left = x + 'px'
        explosionContainer.style.top = y + 'px'
        // Drastically reduce explosion container to just 1.1 times radius
        explosionContainer.style.width = radius * 1.1 + 'px'
        explosionContainer.style.height = radius * 1.1 + 'px'
        explosionContainer.style.transform = 'translate(-50%, -50%)'
        explosionContainer.style.zIndex = '1500'

        // Create central blast
        const centralBlast = document.createElement('div')
        centralBlast.className = 'rocket-explosion-core'
        centralBlast.style.position = 'absolute'
        centralBlast.style.left = '50%'
        centralBlast.style.top = '50%'
        centralBlast.style.width = '0'
        centralBlast.style.height = '0'
        centralBlast.style.transform = 'translate(-50%, -50%)'
        centralBlast.style.borderRadius = '50%'
        centralBlast.style.backgroundColor = '#fff' // White core
        centralBlast.style.boxShadow =
          '0 0 15px 8px rgba(255, 200, 0, 0.8), 0 0 30px 15px rgba(255, 100, 0, 0.6)' // Significantly reduced shadow size
        centralBlast.style.animation = 'rocketExplosionCore 0.6s forwards'
        explosionContainer.appendChild(centralBlast)

        // Create shockwave ring
        const shockwave = document.createElement('div')
        shockwave.className = 'rocket-explosion-shockwave'
        shockwave.style.position = 'absolute'
        shockwave.style.left = '50%'
        shockwave.style.top = '50%'
        shockwave.style.transform = 'translate(-50%, -50%)'
        shockwave.style.width = '0'
        shockwave.style.height = '0'
        shockwave.style.borderRadius = '50%'
        shockwave.style.border = '1px solid rgba(255, 200, 0, 0.6)' // Thinner, more transparent border
        shockwave.style.animation = 'rocketShockwave 0.5s forwards' // Shorter animation
        explosionContainer.appendChild(shockwave)

        // Create particles
        const numParticles = 60 // Fewer particles for a smaller explosion
        for (let i = 0; i < numParticles; i++) {
          const particle = document.createElement('div')
          particle.className = 'rocket-explosion-particle'

          // Calculate random direction for each particle
          const angle = (i / numParticles) * 360 + Math.random() * 30
          const distance = radius * (0.2 + Math.random() * 0.4) // Significantly reduce distance to 20-60% of radius
          const tx = Math.cos((angle * Math.PI) / 180) * distance
          const ty = Math.sin((angle * Math.PI) / 180) * distance

          // Random size and color variations for particles
          const size = 1 + Math.random() * 4 // Smaller particles
          const colors = ['#ff0', '#f80', '#f00']
          const color = colors[Math.floor(Math.random() * colors.length)]

          particle.style.width = size + 'px'
          particle.style.height = size + 'px'
          particle.style.backgroundColor = color
          particle.style.position = 'absolute'
          particle.style.left = '50%'
          particle.style.top = '50%'
          particle.style.transform = 'translate(-50%, -50%)'
          particle.style.borderRadius = '50%'
          particle.style.opacity = Math.random() * 0.3 + 0.7
          particle.style.boxShadow = `0 0 ${size * 2}px ${size}px ${color}`

          // Set animation properties
          particle.style.animation = `rocketParticle${(i % 3) + 1} ${0.4 + Math.random() * 0.4}s forwards`
          particle.style.animationTimingFunction = 'ease-out'

          // Set final position as CSS custom properties
          particle.style.setProperty('--tx', `${tx}px`)
          particle.style.setProperty('--ty', `${ty}px`)

          explosionContainer.appendChild(particle)
        }

        document.body.appendChild(explosionContainer)

        // Remove explosion container after animation completes
        setTimeout(() => {
          if (explosionContainer.parentNode) {
            explosionContainer.parentNode.removeChild(explosionContainer)
          }
        }, 1000)
      }

      // Function to create a special explosion for rocket-saucer hits
      function createRocketSaucerHitExplosion(x, y) {
        // Create container for the explosion
        const explosionContainer = document.createElement('div')
        explosionContainer.className = 'rocket-saucer-hit'
        explosionContainer.style.position = 'absolute'
        explosionContainer.style.left = x + 'px'
        explosionContainer.style.top = y + 'px'
        explosionContainer.style.width = '100px'
        explosionContainer.style.height = '100px'
        explosionContainer.style.transform = 'translate(-50%, -50%)'
        explosionContainer.style.zIndex = '1500'

        // Create energy burst in the center
        const energyBurst = document.createElement('div')
        energyBurst.className = 'energy-burst'
        energyBurst.style.position = 'absolute'
        energyBurst.style.left = '50%'
        energyBurst.style.top = '50%'
        energyBurst.style.width = '0'
        energyBurst.style.height = '0'
        energyBurst.style.transform = 'translate(-50%, -50%)'
        energyBurst.style.borderRadius = '50%'
        energyBurst.style.backgroundColor = '#80ffff' // Cyan center
        energyBurst.style.boxShadow = '0 0 20px 10px rgba(128, 255, 255, 0.8), 0 0 40px 20px rgba(0, 200, 255, 0.6)'
        energyBurst.style.animation = 'energyBurst 0.5s forwards'
        explosionContainer.appendChild(energyBurst)

        // Create electrical arcs
        for (let i = 0; i < 8; i++) {
          const arc = document.createElement('div')
          arc.className = 'electrical-arc'
          arc.style.position = 'absolute'
          arc.style.left = '50%'
          arc.style.top = '50%'
          arc.style.width = '2px'
          arc.style.height = '30px'
          arc.style.backgroundColor = '#80ffff'
          arc.style.transform = `translate(-50%, -50%) rotate(${i * 45}deg)`
          arc.style.transformOrigin = 'center bottom'
          arc.style.animation = `electricalArc 0.4s ease-out forwards ${i * 0.05}s`
          arc.style.boxShadow = '0 0 5px 2px rgba(128, 255, 255, 0.8)'
          arc.style.setProperty('--index', i)
          explosionContainer.appendChild(arc)
        }

        // Create particles
        const numParticles = 30
        const colors = ['#80ffff', '#40a0ff', '#ffffff', '#a0ffff']
        
        for (let i = 0; i < numParticles; i++) {
          const particle = document.createElement('div')
          particle.className = 'rocket-saucer-particle'
          
          // Random size between 2-6 pixels
          const size = 2 + Math.random() * 4
          particle.style.width = `${size}px`
          particle.style.height = `${size}px`
          
          // Random color from our palette
          const color = colors[Math.floor(Math.random() * colors.length)]
          particle.style.backgroundColor = color
          
          particle.style.position = 'absolute'
          particle.style.left = '50%'
          particle.style.top = '50%'
          particle.style.transform = 'translate(-50%, -50%)'
          particle.style.borderRadius = '50%'
          particle.style.boxShadow = `0 0 ${size}px ${size/2}px ${color}`
          
          // Calculate random direction
          const angle = Math.random() * 360
          const distance = 20 + Math.random() * 50
          const tx = Math.cos((angle * Math.PI) / 180) * distance
          const ty = Math.sin((angle * Math.PI) / 180) * distance
          
          // Animation with random duration
          const duration = 0.3 + Math.random() * 0.3
          particle.style.animation = `rocketSaucerParticle ${duration}s ease-out forwards`
          
          // Set CSS variables for the animation
          particle.style.setProperty('--tx', `${tx}px`)
          particle.style.setProperty('--ty', `${ty}px`)
          
          explosionContainer.appendChild(particle)
        }

        document.body.appendChild(explosionContainer)

        // Remove after animation completes
        setTimeout(() => {
          if (explosionContainer.parentNode) {
            explosionContainer.parentNode.removeChild(explosionContainer)
          }
        }, 600)
      }
    </script>
  </body>
</html>
